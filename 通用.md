# 计算机通用知识

## 计算机基础

### 进程、线程、协程
#### 分别是什么
1. 进程 (Process)
定义：进程是操作系统进行资源分配和调度的基本单位。通俗地讲，它就是“一个正在执行的程序”。
关键点：当一个程序（如Chrome浏览器）启动时，操作系统会为其创建一个进程，并分配独立的资源，如：
内存空间（代码段、数据段、堆栈等）
系统资源（如文件句柄、网络端口）
特点：每个进程都有自己独立的内存空间，因此一个进程崩溃一般不会影响其他进程，稳定性高。但进程间的创建、销毁、切换（上下文切换）成本非常高，因为需要切换内存地址空间等。
2. 线程 (Thread)
定义：线程是进程中的一个执行流，是CPU调度和执行的最小单位。一个进程可以包含多个线程。
关键点：同一个进程内的所有线程共享进程的资源（如内存和文件句柄）。
特点：
创建、销毁、切换的成本远低于进程。
因为共享内存，线程间通信非常方便（直接读写同一块内存即可）。
但也正因为共享资源，一个线程崩溃可能导致整个进程崩溃，从而波及同进程内的其他线程。需要谨慎处理线程同步（如加锁）问题，否则会产生竞态条件、死锁等问题。
3. 协程 (Coroutine)
定义：协程是一种比线程更加轻量级的存在，由程序员在用户态进行控制，也称为“用户态线程”或“纤程 (Fiber)”。
关键点：协程的调度完全由用户程序控制，而不是由操作系统内核的调度器抢占式调度。
特点：
极其轻量：创建和切换成本极低，你可以轻松创建成千上万个协程。
非抢占式调度：协程主动让出（yield）执行权，而不是被系统强制中断。这意味着切换时机是明确的，不需要复杂的锁机制。
同步代码写异步逻辑：让代码看起来是同步顺序执行的，但实际执行过程是异步跳转的，非常适合处理高并发的I/O密集型任务（如网络请求）。
#### 对比
特性|进程 (Process)|线程 (Thread)|协程 (Coroutine)
基本单位	资源分配的基本单位	CPU调度和执行的基本单位	用户态调度的执行流
资源占用	多（独立内存、资源）	中等（共享进程内存）	极少（通常只需一个栈空间）
切换成本	高（需要切换内存空间，CPU缓存失效）	中（需要内核介入）	极低（用户态控制，无需内核介入）
创建数量	少（几十上百个）	中（几百上千个）	极多（几万、几十万个）
数据共享	进程间通信(IPC)复杂（如管道、消息队列）	共享同一进程内存，通信简单	共享同一线程内存，通信最简单
稳定性	高，一个进程崩溃不影响其他进程	低，一个线程崩溃可能导致整个进程崩溃	高，一个协程崩溃只影响自己
调度机制	由操作系统内核进行抢占式调度	由操作系统内核进行抢占式调度	由用户程序（开发者）协作式调度
实现级别	操作系统级别	操作系统级别	用户程序/语言/库级别 (如Go的goroutine)
典型应用	运行独立的程序（Chrome, Word）	一个程序内多任务（UI线程、网络线程）	高并发网络服务（Go, Python gevent）
#### 技术场景举列子
1. 进程 vs 线程
你打开一个Chrome浏览器，它就是一个进程。在这个浏览器进程里：
一个线程负责渲染网页界面（UI线程）。
一个线程负责处理你的鼠标点击事件。
一个线程负责发送网络请求。
一个线程负责执行JavaScript代码。
这些线程共享Chrome这个进程的内存（如打开的网页数据）。
2. 线程 vs 协程
假设你要写一个爬虫，需要并发地爬取1000个网页。
多线程方案：你创建100个线程，每个线程爬10个网页。
问题：创建100个线程开销很大，而且线程间的切换由操作系统决定，你可能需要处理很多锁的问题。
协程方案（例如用Go语言的goroutine）：你创建1000个协程，每个协程爬1个网页。
原理：当一个协程发起网络请求（这是一个阻塞操作）时，它主动通知调度器：“我要等数据了，别让我闲着，快去执行其他准备好的协程”。调度器就立刻去执行其他协程。
优势：这1000个协程可能只映射到几个操作系统线程上。用同步的代码逻辑，实现了极高的异步并发性能，且资源消耗极低。
两者的协作方式：
协程需要“寄生”在线程上运行。一个或多个协程跑在一个线程里。它们之间的映射关系主要有两种模式：
N:1 模型：N个协程运行在1个线程上。优点是极轻量，切换极快；缺点是无法利用多核CPU。
M:N 模型：M个协程运行在N个线程上（M远大于N）。这是最复杂的也是最高效的模式（如Go语言的GMP模型）。它既能享受协程轻量的好处，又能利用多核优势。
结论： 你可以把协程看作是在线程之上实现的一套更聪明的“任务调度算法”，它和线程是不同层次的技术。
#### 总结
传统的线程，每条流水线都在启动时就安排好了各自的任务，甚至有的执行完了之后就没事干了，也就是这个线程对应的cpu核心在休息。除非又触发了该线程需要处理的任务类型，才继续工作。
而协程，可以让几个线程被任务调度器（事件循环）管理，将任务库的任务按照顺序分发给各个线程工作，且会监视这些任务的进度，当任务处理到需要等待返回结果时，就先把任务暂停并记录暂停的进度，且会关注这个任务的返回情况，然后把任务库中需要执行的下一条任务安排至线程处理。而当之前被先暂停的任务有返回结果了，则会将该任务重写标记为就绪，加入要被执行的任务队列，等到有线程有空余，且该任务是待执行的第一条时，又可以继续执行得到结果了。
核心来说，协程是用了一个任务调度器来更加高效的利用线程的资源了。

### 三大编程思想：POP、OOP、AOP
#### pop
面向整个过程，也就是按顺序一步步执行，事件越复杂，则实现越困难，且代码复用性很低.
#### oop
将需要干活的内容，尽可能分割为小块，每个对象能完成小块的工作。所以这个对象复用性很高。
#### aop
面向切面，作用还是进一步抽取，将oop中多个对象处理的业务模块中，重复的部分，继续抽离，比如打印日志这种公共的事务，在各个oop对象模块都要用到的。
这个抽取后的任务，继续封装为一个模块，然后这个模块在需要的时刻，用一些方法注入到之前oop的各个模块中。
1. 编译时织入 (Compile-Time Weaving)
原理：在源代码编译成可执行代码之前，由一个特殊的“织入器”处理。这个织入器会读取核心业务代码和切面定义，然后将切面的逻辑“编织”到指定的业务方法中，最终生成一份合并后的新代码。
举个例子：
假设你有原始代码 UserService.js 和切面 LoggingAspect.js。
织入器会处理它们，并最终生成一个 UserService_Woven.js 文件。这个新文件里的 createUser 方法已经自动包含了日志逻辑。
实现技术
AspectJ (Java 领域最著名的 AOP 框架)：它有自己的编译器 (ajc)，专门干这个事情。
TypeScript 转换器 (Transformer)：如果你用 TypeScript，可以在编译阶段通过自定义转换器来实现类似的织入。
特点：性能最好，因为注入工作在编译期就完成了，运行时没有任何开销。但对工具链有依赖。
2. 运行时织入 (Runtime Weaving) / 代理模式 (Proxy)
原理：这是 JavaScript 中最常见、最容易理解的实现方式。它利用 “代理”模式，在应用程序运行时，动态地创建一个包装了原始对象的代理对象。所有对原始对象方法的调用，都会先经过这个代理对象，代理对象就有机会在执行前后插入切面逻辑。
现代 JavaScript 提供了 Proxy 对象来实现这一机制。
```js
// 1. 核心业务类 (对切面一无所知，非常纯净)
class UserService {
    createUser(name) {
        console.log(`核心逻辑：创建用户 ${name}`);
        return { id: 1, name: name };
    }
}

// 2. 切面逻辑 (也是一个独立的模块)
const loggingAspect = {
    before: (methodName, args) => {
        console.log(`[日志] 即将执行方法: ${methodName}, 参数: ${JSON.stringify(args)}`);
    },
    after: (methodName, result) => {
        console.log(`[日志] 方法执行完成: ${methodName}, 返回值: ${JSON.stringify(result)}`);
    }
};

// 3. 【关键的织入过程】：创建一个代理工厂
function createProxy(target, aspect) {
    return new Proxy(target, {
        get: (obj, prop) => {
            // 只代理方法，不代理属性
            if (typeof obj[prop] === 'function') {
                return (...args) => {
                    // 【Before 注入点】
                    aspect.before(prop, args);

                    // 执行原始方法
                    const result = obj[prop].apply(obj, args);

                    // 如果方法是异步的，需要处理Promise
                    if (result && typeof result.then === 'function') {
                        return result.then(data => {
                            // 【After 注入点 (对于异步方法)】
                            aspect.after(prop, data);
                            return data;
                        });
                    } else {
                        // 【After 注入点 (对于同步方法)】
                        aspect.after(prop, result);
                        return result;
                    }
                };
            }
            return obj[prop];
        }
    });
}

// 4. 使用：创建原始对象，然后用代理包装它
const originalService = new UserService();
const proxiedService = createProxy(originalService, loggingAspect);

// 5. 现在调用代理后的对象，切面逻辑会自动执行
proxiedService.createUser('Alice');

// 输出：
// [日志] 即将执行方法: createUser, 参数: ["Alice"]
// 核心逻辑：创建用户 Alice
// [日志] 方法执行完成: createUser, 返回值: {"id":1,"name":"Alice"}
```
特点：非常灵活，纯 JavaScript 即可实现，无需额外编译工具。是大多数 JS AOP 库的实现原理。
3. 加载时织入 (Load-Time Weaving, LTW)
原理：这是编译时织入和运行时织入的折中方案。它在类加载器将字节码加载到 JVM（或类似环境）的过程中，动态地对字节码进行修改和织入。
实现技术：
在 Java 中，需要特殊的类加载器或 JVM 代理 (-javaagent)。
在 JavaScript 中，这个概念不太常见，但如果你使用一些高级的模块加载器（SystemJS），理论上也可以实现。
特点：它介于前两者之间，无需修改源码，也无需提前编译，但需要特定的运行时环境支持。
#### 在实际框架中的应用
Express.js / Koa 的中间件 (Middleware)：这就是 AOP 思想的完美体现！每个中间件都是一个“切面”，负责一项横切关注点（如日志、 body解析、会话管理、路由）。它们被“织入”到 HTTP 请求/响应的生命周期中，而你的核心路由处理函数对此一无所知，保持纯净。

React 的高阶组件 (HOC) 和 Vue 的混入 (Mixins)：它们也是为了解决横切关注点（如权限控制、数据获取），可以看作是在组件层面的一种 AOP 实践。

NestJS：这个框架更是将 AOP 作为其核心架构，内置了拦截器、守卫、管道、异常过滤器等机制，这些都是官方的、标准化的“切面”，让你可以非常优雅地实现各种横切逻辑。

所以，AOP 并不是一个遥远的理论，而是你已经在使用却可能没意识到其正式名称的强大编程思想。它的“注入”魔法主要是通过 代理模式 和 特殊的编译/加载流程 来实现的。


### 算法复杂度
算法复杂度是衡量一个算法好坏的关键指标，它不依赖具体的机器性能，只关注随着数据规模增大，算法所需时间和空间的增长趋势。
1. 时间复杂度 (Time Complexity)
概念：不是计算程序具体的运行时间，而是计算算法执行基本操作次数的增长趋势。用大 O 表示法 (O(...)) 来描述。
常见复杂度（从好到坏）：
O(1)：常数时间。操作次数不随数据规模变化。例如：访问数组的第 i 个元素。
O(log n)：对数时间。非常高效，数据量翻倍，操作次数只加 1。例如：二分查找。
O(n)：线性时间。操作次数与数据规模 n 成正比。例如：遍历一个数组。
O(n²)：平方时间。操作次数是 n 的平方。例如：双重循环。
O(2^n)：指数时间。非常糟糕，通常不可用。例如：暴力破解密码。
2. 空间复杂度 (Space Complexity)
概念：算法在运行过程中临时占用存储空间大小的增长趋势。
常见复杂度：
O(1)：原地算法。只占用常数级别的额外空间。例如：冒泡排序。
O(n)：需要额外开辟一个与输入数据规模 n 成正比的空间。例如：将原数组复制一份。

### 函数式编程、柯里化、管道&组合式
柯里化的目的：是将复杂任务分解为单任务的思想，尽可能细化步骤；
而组合和管道的目的：是将柯里化后的结果，按照业务逻辑，组合成一条加工流水线。
他们两个方面是相辅相成的，可以减少耦合度，利于维护，利于复用。

## 网络基础

### 网络基本运行原理
#### 总览各层：
应用层 -> 传输层 -> 网络层 -> 数据链路层
应用层 (HTTP)：浏览器生成一个 HTTP GET 请求数据包。
传输层 (TCP)：TCP协议在HTTP数据前面加上一个 TCP头。
TCP头里有什么？：源端口号（你的浏览器随机开启的）、目标端口号（Web服务器默认的80端口）、序列号（用于保证顺序）、确认号等。
现在数据变成了：[TCP头] + [HTTP数据]
（这就像把信纸塞进一个信封，信封上写了“寄件人端口：54321，收件人端口：80”）
网络层 (IP)：IP协议在TCP数据包前面再加上一个 IP头。
IP头里有什么？：源IP地址（你家的IP，如120.120.120.120）、目标IP地址（通过DNS查询得到的www.example.com的IP，如93.184.216.34）。
现在数据变成了：[IP头] + [TCP头] + [HTTP数据]
（这就像把上一个信封塞进一个更大的邮包，邮包上写了“寄件人IP：120.120.120.120，收件人IP：93.184.216.34”）
数据链路层 (Ethernet/Wi-Fi)：这是最后一步，数据包要被转换成电信号/电磁波发送出去了。但它不能直接发送IP包，它需要再套一个壳子——以太网帧头。
帧头里有什么？：目标MAC地址、源MAC地址。
关键问题：目标MAC地址填谁？ 你的电脑不知道93.184.216.34的MAC地址。它通过 ARP协议 在本地局域网内大喊：“谁的IP是192.168.1.1（你家路由器的IP）？请把你的MAC地址告诉我！” 你家路由器会回答：“是我，我的MAC是AA:BB:CC:DD:EE:FF！”
于是，数据包被封装成：[帧头 (目标MAC: AA:BB:CC:DD:EE:FF)] + [IP头] + [TCP头] + [HTTP数据] + [帧尾]

#### 链路层
含义：就是一个数据怎么从一个设备到互联网中，再到另一个设备。
1、首先，每个设备都有自己的MAC物理地址（一般不可修改），然后也有一个由对应的网络服务商提供的IP地址（可以动态变化）。
2、然后网络中存在很多路由器，这些路由器也有自己的IP和MAC地址，且这些路由器，分别属于各个网络运营商管理。
3、然后运行过程：
（1）我的设备中一个应用发出数据了，这个数据会被层层包裹，例如HTTP的格式、TCP的头、IP的头、最后是以太网帧头。
（2）这个以太网帧头第一次就是自己家里的路由器的MAC地址，这个是因为ARP协议中设备发出求问的信号时，会被最近的路由器收到并返回；
（3）所以自己的路由器第一次收到这个数据包后，发现这个包是发给自己的，然后就收下，然后拆开看这个包具体想要发送的对象的IP，然后查询自己的路由表，看这个IP的数据发送给自己能发的路由器中哪个最快，也就是运营商网络中的某个中转路由器；
（4）同样的，自家的路由器也通过ARP询问，拿到了中转路由器的MAC，所以重新包装了数据，然后发出去了；
（5）然后运营商的路由器收到了这个数据，发现MAC是自己，就接收并解析，重复上述的拆包和重新包装MAC；
（6）直到运营商的路由器发现，自己就是最快的能把这个数据包发送到对方运营商路由器的了，就再次包装以太网帧头。这次这个数据从一家运营商的局域网，传递到了另一家运营商的局域网了。（本质上不管是哪个运营商，他们只是建立了这些路由器和线路，然后他们能管理这些路由器，当监测到接收方的ip有问题时，例如防火墙和避免访问的一些网站，可以选择让该路由器不继续发送这个数据包）
（7）后续重复以上过程，直到数据到达用户甲的路由器，然后这个路由器把数据传到用户设备，用户设备的网卡发现MAC是自己，就收下了数据，然后由操作系统分配给对应的应用处理。
补充：关于路由表
路由表是动态生成的，其维护是一个分层、协作的过程，结合了手动配置和自动学习。
1. 运营商核心网络（骨干网）内部：
协议： 主要使用 OSPF、IS-IS 等内部网关协议。
如何工作： 同一个运营商网络内的所有路由器之间会互相通信，不断地告诉对方：“我直接连接了哪些网络”、“到达我这里的开销（Cost）是多少”。通过这种复杂的算法，每个路由器都能自动计算出一张到达全网所有目标的最优路径地图。
结论： 在运营商内部，路由表是自动学习和维护的，无需手动配置每一条规则。这保证了网络的高效和自愈能力（某条线路断了，路由协议会自动计算新路径并更新所有路由器的路由表）。
2. 不同运营商网络之间（互联网层面）：
协议： 使用 BGP 这个外部网关协议。
如何工作： 这更像是一种“外交谈判”。运营商的边界路由器会互相通告：“我这边可以通往哪些IP地址段（即我承载了哪些网络）”。这种通告包含了丰富的策略，比如“我宁愿走贵的线路也不要把流量经过竞争对手的网络”。
结论： 运营商之间的路由（BGP）很大程度上是手动配置和基于策略管理的。网络工程师会手动定义与哪些“邻居”（其他运营商）建立BGP会话，以及通告哪些路由信息。这使得BGP非常强大和灵活，但也更复杂。
3. 你的家庭/企业路由器：
它的路由表通常非常简单。
默认路由： 最重要的一条规则是：“所有目标地址（0.0.0.0/0）的流量，都发给运营商给我的那个网关地址（如211.111.111.1）”。这意味着“所有你不知道怎么走的包，都扔给运营商，让他们去处理”。
本地网络路由： 另一条规则是：“目的地是192.168.1.0/24（我家局域网）的流量，直接通过LAN口发送，不用转发”。
所以，总结一下：
路由表不是由某一个中心机构维护的，而是互联网这个去中心化系统协作的产物。
局域网内的路由通过OSPF等协议自动学习。
全球互联网的路由通过BGP协议“协商”和“策略配置” 而来。
最终用户的路由器则设置一个简单的默认路由，指向自己的运营商。

4、总结：核心还是MAC地址和路由器以及路由表
MAC地址：每个用户及路由器中间人的具体实际地址。
路由器：执行了接收数据及分发数据的中介功能。
路由表：让路由器知晓，去往数据包中最终接收者的IP，在自己能力范围内，向下一个路由器发送时，给谁发路径最短时间最快。

#### 网络层
IP协议：负责将数据包从一个网络设备路由到另一个网络设备。它只关心目标IP地址，像邮局一样负责分拣和运输，但不保证包裹不丢失、不顺序错乱。

#### 传输层
传输层：基于刚刚的链路层传送数据的形式下，具体如何发数据包的规则。
TCP/IP：规定的连接后在发数据，其实本质就是，先发送几个基本的打招呼的数据包，来让双方进行确认对方目前实时存在且在监听网络，然后才开始发送想要发送的数据本体。
正如你所说，它本质上是三次握手所达成的一个“状态共识”。
状态初始化：三次握手成功后，你的电脑和服务器都在自己的操作系统内核中创建了一个叫做 TCB（传输控制块） 的数据结构。
这个TCB记录了什麼？
  源IP、源端口、目标IP、目标端口（这条连接的唯一标识，也叫“四元组”）
  序列号（Sequence Number）和确认号（Acknowledgment Number）：这是保证数据顺序和可靠性的核心。双方通过握手同步了序列号的初始值。
  发送和接收缓冲区：用来临时存放要发送和刚接收到的数据。
  流量控制窗口：用来控制发送速度，避免对方来不及处理。
“连接”的存在意义：这个TCB状态，使得后续所有符合这个“四元组”的数据包，都能够被双方正确地处理：排序、确认、重传、提交给应用层。没有这个状态，过来的数据包就只是一堆无法识别的、混乱的UDP包。
一个更准确的比喻
把互联网的数据传输想象成通过邮政系统寄明信片（每个明信片就是一个IP数据包）。
没有连接（UDP）：你直接写地址寄出一张明信片。它可能丢失、乱序。你无法知道对方收没收到。
建立TCP连接：在开始寄重要的信件之前，你先和对方进行一次“三次握手”：
你寄出一张明信片，上面写着：“我的序列号从100开始，你准备好了吗？”（SYN）
对方收到后，回寄一张明信片：“我收到了你的100，我的序列号从300开始，我准备好了，你呢？”（SYN-ACK）
你收到回信后，再寄出一张：“我收到了你的300，我们开始吧！”（ACK）
现在，“连接”建立了！ 这个“连接”是什么？它不是邮政局为你们俩新开了一条邮路，而是你们双方都拿了一个小本子（TCB），你记录下来：“我和A的通信，我的序号从100开始，他的序号从300开始”。对方也做了同样的记录。
之后你们寄出的每一张明信片（数据包），都会带上一个序号（101， 102...），对方收到后，会检查序号是否连续，并回信告诉你：“301号明信片我收到了，请寄下一张103号”。如果你没收到确认，你就知道明信片丢了，需要重寄。
所以，TCP建立的不是一个物理管道，而是一个复杂的、双边的“通信状态和约定”。

UDP：没有前置的发送几个打招呼确认双方都在线的数据包，而是直接发送数据本体，如果接收方在线就能收到（没有其他的例外因素打扰下），而接收方不在线，那就丢了这个数据。

TCP/IP 和UDP最大的区别就是：TCP/IP是面向连接的，UDP是无连接的。TCP协议和UDP协议各有所长、各有所短，适用于不同要求的通信环境。TCP协议和UDP协议之间的差别如下表所示。
在实际的使用中，TCP主要应用于文件传输精确性相对要求较高且不是很紧急的情景，比如电子邮件、远程登录等。UDP可以提高传输效率，所以UDP被广泛应用于数据量大且精确性要求不高的数据传输，比如我们平常在网站上观看视频或者听音乐的时候应用的基本上都是UDP传输协议。

具体应用：
选择对应的那种库（TCP/IP或者UDP协议对应的代码运行库）来创建socket来监听网络信号来决定传输层协议类型。
```js
// Node.js 示例 
// 创建 TCP Socket：
const net = require('net');
const socket = net.createConnection({ port: 80, host: 'example.com' }, () => {
  console.log('TCP连接已建立！');
  socket.write('你好！'); // 发送数据
});
// 创建 UDP Socket：
const dgram = require('dgram');
const socket = dgram.createSocket('udp4');
socket.send(Buffer.from('你好！'), 1234, 'example.com', (err) => {
  console.log('UDP数据包已发送！');
});
```
如果你在开发 Web 应用（前端）：
你无法直接选择传输层协议。
你发起的 HTTP 请求，浏览器会自动使用 TCP 协议来传输。
你使用的 WebRTC（用于视频聊天等）技术，它在底层混合使用了 TCP 和 UDP（为高质量音视频使用UDP），但这对你也是透明的。
结论：在标准Web开发中，协议的选择是由你使用的“应用层协议”决定的。 你选择用HTTP，就等于选择了TCP。

#### 应用层
HTTP 和 HTTPS 的定义
HTTP（超文本传输协议，Hypertext Transfer Protocol）是一种用于分布式、协作式、超媒体信息系统的应用层协议。它允许客户端（如浏览器）与服务器之间进行通信，以请求和传输网页、图片、视频等资源。HTTP 基于请求-响应模型，客户端发送请求到服务器，服务器处理请求后返回响应。
HTTPS（安全超文本传输协议，Hypertext Transfer Protocol Secure）是 HTTP 的安全版本，通过在 HTTP 的基础上添加 SSL/TLS（安全套接字层/传输层安全性）协议来实现数据加密和安全传输。HTTPS 不仅能够传输数据，还能确保数据的机密性、完整性和身份验证，防止数据在传输过程中被窃取或篡改。SEO 和新技术必备：Google 等搜索引擎优先排名 HTTPS 网站。许多现代 Web API（如地理位置、Service Worker）都要求 HTTPS。
总结：首先是TCP/IP建立通讯，然后HTTP协议（规定数据的格式）发送数据，在发送前和接受后用SSL/TLS协议进行加密和解密。
##### HTTP2
1. HTTP/2 是对应用层协议的改进，它仍然运行在 TCP 之上。它的主要目标是解决 HTTP/1.1 在性能上的瓶颈。
特性	HTTP/1.1	HTTP/2	带来的好处
连接方式	多个连接	多路复用	解决了队头阻塞，极大提升效率
数据格式	纯文本	二进制分帧	解析更高效，错误更少
头部压缩	重复发送	HPACK 压缩	大大减少了冗余数据，节省带宽
服务器推送	不支持	支持	服务器可主动推送资源，减少请求延迟
重点解释“多路复用”：
HTTP/1.1 的问题：虽然允许复用TCP连接，但请求和响应必须是顺序排队的（队头阻塞）。如果第一个请求处理慢，后面的请求即使完成了也要等着。
HTTP/2 的解决方案：它将每个请求拆分成多个二进制帧，并给它们打上ID标签。这些帧可以乱序发送，在对方接收后再根据ID重新组装。这样，多个请求和响应可以混杂在一起同时进行，一个请求的延迟不会阻塞其他请求。
2. 如何选择和使用？（如何开启）
开启 HTTP/2 的唯一前提是：你的服务器必须安装并配置了 SSL/TLS 证书，支持 HTTPS。 因为几乎所有浏览器都只允许在加密连接上使用 HTTP/2。
为你的网站部署 HTTPS：从云服务商或 Let's Encrypt 获取 SSL/TLS 证书并在你的服务器（如 Nginx, Apache）上配置好。
更新服务器配置：现代版本的 Web 服务器（如 Nginx、Apache）默认已支持 HTTP/2。你通常只需要在服务器的配置文件中，将 listen 443 ssl; 修改为 listen 443 ssl http2; 并重启服务即可。
```
server {
    listen 443 ssl http2; # 就是这里多了 http2
    server_name yourdomain.com;
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/private.key;
    ...其他配置...
}
```
网页资源被部署的服务器中，这个服务器设置监听的协议格式来决定应用层的协议（如上是H2）。开启HTTP/2：这是服务器配置的工作。前端开发者只需确保项目部署在已正确配置HTTP/2的服务器上即可，无需修改任何前端代码。
3. 浏览器如何知道该用哪个HTTP协议？
当你在浏览器输入网址并按回车后，整个过程如下：
建立TCP连接：浏览器首先与服务器的 443 端口（HTTPS）建立一条 TCP 连接。这是所有后续对话的基础。
TLS握手与协议协商：在TCP连接之上，浏览器会立即发起 TLS 握手（以前叫SSL握手），目的是建立加密通道。正是在这个握手阶段，浏览器和服务器会协商接下来使用哪个应用层协议。
浏览器在 ClientHello 消息中会说：“我支持这些协议哦：HTTP/2 (h2), HTTP/1.1, 等等...”。
服务器在 ServerHello 消息中回复：“好的，我们从这些里面选一个最高级的吧，我们就用 HTTP/2 来通信！”
这个协商过程由 ALPN 扩展实现。
开始应用层通信：TLS握手完成后，加密通道建立，并且双方也达成一致：“我们将使用 HTTP/2 协议来对话”。此后，所有的 HTTP 请求和响应都会遵循 HTTP/2 的二进制分帧格式在这个加密的 TCP 连接上进行。
总结：HTTP协议的版本协商不是在TCP三次握手时确认的，而是在之后的TLS握手阶段确认的。

##### WebSocket
是什么：
WebSocket是一种在单个TCP连接上进行全双工通信的协议。它解决了HTTP协议的一个核心痛点：HTTP只能由客户端主动发起请求，服务器不能主动“推送”消息给客户端。
如何使用：
现代浏览器都原生支持WebSocket API，无需额外库即可直接使用：
```js
// 创建 WebSocket 连接，连接到指定的服务器端点
// 注意协议是 ws:// (非加密) 或 wss:// (加密，用于生产环境)
const socket = new WebSocket('wss://your-websocket-server.com/chat');

// 监听事件
// 1. 当连接成功建立时触发
socket.onopen = (event) => {
  console.log('Connected to the WebSocket Server');
  // 连接成功后，可以立即发送一条消息
  socket.send('Hello Server! User has joined.');
};

// 2. 当从服务器收到消息时触发 (这是最核心的事件)
socket.onmessage = (event) => {
  // 服务器发送的数据在 event.data 里
  console.log('Message from server:', event.data);

  // 【这就是你提到的处理展示逻辑】
  // 通常服务器会发送JSON格式的字符串，我们需要解析它
  try {
    const data = JSON.parse(event.data);
    // 根据数据内容更新UI，例如：
    if (data.type === 'new_message') {
      appendMessageToChatUI(data.user, data.text); // 自定义函数，将消息添加到聊天界面
    } else if (data.type === 'user_count') {
      updateUserCountUI(data.count); // 自定义函数，更新在线人数显示
    }
  } catch (e) {
    // 如果不是JSON，直接处理
    console.log(event.data);
  }
};

// 3. 当连接发生错误时触发
socket.onerror = (error) => {
  console.error('WebSocket Error:', error);
};

// 4. 当连接关闭时触发
socket.onclose = (event) => {
  console.log('Connection closed', event.code, event.reason);
};

// 5. 发送纯文本
socket.send('Hello World!');

// 更常见的做法：发送JSON字符串
const message = {
  type: 'send_message',
  text: 'This is my message content'
};
socket.send(JSON.stringify(message)); // 将对象转为字符串发送
```
以上前端代码必须有一个支持WebSocket的后端服务来配合。这个后端服务需要：
  监听一个网络端口（如8080）。
  实现WebSocket协议握手逻辑。
  管理所有客户端的连接。
  接收来自某个客户端的消息，并可以决定广播给所有其他客户端，或者只发回给发送者。
常用的后端语言都有成熟的库来实现WebSocket服务：
  Node.js: ws, Socket.IO
  Python: websockets, Django Channels
  Java: Jakarta WebSocket API
  Go: gorilla/websocket
所以，前端代码负责连接、发送和接收处理，后端代码负责维持连接和消息路由，两者共同协作才能实现完整的实时功能。你对于前端部分如何工作的理解是完全正确的！

对于复杂项目（如需要断线重连、心跳检测等），常用的第三方库有 Socket.IO。它简化了使用方式，并提供了更强的健壮性，但它底层通信依然是（或降级到）WebSocket。
使用场景：
任何需要服务器主动、实时地向客户端推送数据的场景，都是WebSocket的用武之地：
实时聊天应用：微信、钉钉、Telegram等。消息一来，立刻显示，无需你不停刷新。
实时数据Dashboard：股票行情、实时销量统计、服务器监控大屏。数据变化时，页面数字实时跳动。
多人在线协作：在线文档（如Google Docs）、协同绘图（如Figma）。你看到一个协作者的光标位置和操作是实时同步的。
在线游戏：多玩家对战的游戏，需要极低的通信延迟和实时状态同步。
体育实况更新：比分直播、赛事文字直播。
总结一下：WebSocket在HTTP协议之上，为Web应用打开了实时双向通信的大门，是构建现代富交互Web应用的基石技术之一。
##### 对比Websocket和Axios
相似点：
1、axios本质也是发送一个消息：消息的内容包括需要访问的ip+port来定位服务器，然后后面的path及params来让服务器判断客户端需要的资源和携带的参数。
2、socket.send，也是发送一个消息，定位的信息在之前new socket就确定了，而send的信息的作用其实是跟axios发送的url中的path和params或者data等一样的，是告知服务器客户端需要的资源以及客户端提供的参数及数据的。
不同点：
1、axios的请求，没有提前规定好发送目的地，而socket在new出来时就规定好了接收者。
2、axios无法持续监听服务器发送的消息，是一次性的发出消息然后等待回到的消息。而socket可以持续监听服务器的消息。
3、HTTP (Axios) 是无状态的：服务器不会记住你上一次的请求。每一次请求都是一个全新的、独立的对话。如果你需要维持状态（如用户登录），必须每次通过Cookie、Token等方式显式地告诉服务器“我是谁”。WebSocket 是有状态的：从 new WebSocket() 成功到 onclose 触发之前，这条TCP连接一直是存在的。服务器可以在内存中维护这个连接对象以及与之相关的状态信息（如这个用户是谁、在哪个房间），服务器知道“你”是谁。

使用场景：
使用 Axios (HTTP) 的场景：（占Web开发的90%以上）
  获取页面内容：加载HTML、CSS、JS文件。
  提交表单：用户登录、注册、提交订单。
  获取数据：翻页加载文章列表、查询用户信息、获取配置项。
  上传/下载文件。
  任何不需要服务器主动“推送”数据的场景。特点是：由用户交互触发，获取结果后交互就结束了。
使用 WebSocket 的场景：（特定的实时应用）
  实时聊天（微信、钉钉）：核心场景，消息必须被即时推送。
  实时数据大屏（股票行情、体育比分、监控系统）：数据持续变化，需要实时反映到屏幕上。
  多人在线协作（Figma、Google Docs）：看到他人在屏幕上的光标位置和操作必须是实时的。
  在线游戏（棋牌类、简单IO游戏）：游戏状态需要极低延迟地同步给所有玩家。
  实时通知（网页版邮箱的新邮件提醒、GitHub的PR提醒）。


### DNS解析及CDN加速原理
如果本地host及浏览器dns缓存都没有一个域名对应的ip端口，则会向本地DNS服务器（通常是运营商维护的）进行查询；
如果本地DNS服务器有该域名的缓存则直接返回ip，如果没有则本地DNS服务器会向更高等级的DNS服务器进行查询，直到查询到ip后，缓存并返回给客户端；
如果这个域名对应的是CDN的，则更高级的DNS服务器不会直接返回一个ip，而是一条CNAME记录：www.example.com -> www.example.com.cdn.dnsv1.com.意思是你要去找这个网址要ip，这个新的域名就是CDN厂商提供的智能DNS系统的域名；
于是本地DNS服务器再次发起查询，这次的目标是找到 www.example.com.cdn.dnsv1.com 的IP。最终会到达CDN厂商搭建的全局智能DNS系统；
智能DNS系统收到查询请求后，看的不是最终用户的IP，而是查看查询者的IP，也就是【北京联通本地DNS服务器】的IP地址；然后根据计算得出距离这个本地DNS的IP最方便快捷的分发服务器的IP并返回给本地DNS服务器；
本地DNS服务器缓存该ip，并返回给客户端；
客户端进行访问ip。

### 同源概念及跨域问题
#### 同源
同源策略的本质是：协议、ip、端口，这三者完全相同就是同源、有一个不同就是不同源。
同源策略是浏览器根据是否同源而做出的动作：
  浏览器在一个页面中的脚本发送同源的请求时，会允许请求且能收到res；而浏览器中一个页面中的脚本发送了一个不同源的请求时，浏览器会阻止该脚本收到res。
  浏览器会自动在同源请求中携带该源对应的Cookie
#### 跨域
跨域的本质：
  而当一个html中的js，访问了服务器api时（通常使用了cdn分发静态资源、中央服务器提供动态api资源），会触发跨域问题，因为在一个源的网页中的脚本向另一个源发起了请求。
解决跨域：
  1）cors：中央服务器给res响应头中设置Access-Control-Allow-相关的字段，告诉浏览器，我返回的数据，哪些访问者可以看，在Access-Control-Allow-Origin白名单中的网页能看到结果，不在的就不能看。
  预检：
  简单请求不触发预检：
    简单请求方法为：GET, HEAD, POST；头部仅包含：Accept, Accept-Language, Content-Language, Content-Type (值仅限 application/x-www-form-urlencoded, multipart/form-data, text/plain)；请求中的任意XMLHttpRequestUpload对象均没有注册任何事件监听器。
    浏览器直接发出请求，收到响应后检查CORS头。如果服务器允许，则JS就能读到响应；如果不允许，则触发CORS错误。
  非简单请求：
    使用了 PUT, DELETE, PATCH 等方法；设置了自定义头部（如 Authorization, X-Custom-Header）；Content-Type 值为 application/json。
    对于非简单请求：浏览器会先自动发起一个 OPTIONS 方法的预检请求：浏览器发现js脚本向不同源的网站进行非简单请求了，那么浏览器会先不发送这个请求，而是发送一个预检请求，这个请求会携带原html的域名信息，而服务器收到请求后，会返回一个res，这个res携带了上述的Access-Control-Allow-相关的字段，然后浏览器会判断原html的域是否被包含在内，在的话就继续发送之前js需要请求的资源，然后把收到的数据给到js脚本进行处理。
  2）反向代理：让html中的js不直接访问不同源的后端服务器，而是访问一个与html同源的服务器，然后由该服务器识别到url后的路径及参数时代替继续访问真实的后端服务器去取数据，然后再返回给浏览器，浏览器就不会触发跨域问题了。（那这样的话，本质就是没有触发跨域问题，是跳过跨域了，而不是解决跨域问题，本质上浏览器只是一直向一个服务器在请求资源）
总结：CORS是“查询白名单”，而反向代理是“绕开跨域问题”。


### 代理
正反向代理的本质：区别就是这个代理的中介会把客户端还是服务端的真实信息不暴露给剩余的一方
代理类型	正向代理 (Forward Proxy)	反向代理 (Reverse Proxy)
代理的对象	客户端	服务端
隐藏了谁	隐藏了客户端的身份。服务器只知道代理的IP，不知道真正客户的IP。	隐藏了服务端的身份。客户端只知道代理的地址，不知道后面是哪个服务器在处理。
站在谁的立场	客户端的代理。客户端主动配置和使用它。	服务端的代理。服务器部署它，客户端无感知。
经典场景	科学上网：你（客户端）配置代理，代理帮你访问Google，Google（服务端）以为请求是代理发的。	网站访问：你访问 www.example.com，实际上是访问了Nginx（反向代理），Nginx再把请求转发给后面真正的Tomcat/Node.js服务器。

### cookie相关
#### cookie的常用属性
Secure; 它只能通过HTTPS协议发送
HttpOnly; 它只能被浏览器发送请求时携带，不可以被js脚本读取
Expires/Max-Age; 它会在指定时间过期
Domain; 定义哪些主机可以接收这个Cookie
Path; 指定URL路径前缀，只有路径匹配时才会发送Cookie
SameSite属性的影响
  ‌Strict‌：严格禁止第三方Cookie，仅同源请求携带。 ‌
  ‌Lax‌：允许导航请求（如点击链接）携带Cookie，但限制其他跨域请求。 ‌
  ‌None‌：允许所有跨域请求携带Cookie。
```http
<!-- 服务端设置的 -->
Set-Cookie: sessionid=abc123def456; 
  Expires=Wed, 21 Oct 2024 07:28:00 GMT; # 设置过期时间
  Max-Age=2592000;                       # 另一种设置方式（30天）
  Domain=.example.com;                   # 对所有子域名有效
  Path=/;                                # 对整个网站有效
  Secure;                                # 仅HTTPS发送
  HttpOnly                               # JS无法访问
```
以上都是为了保障cookie的安全，存储敏感信息，尤其是身份认证令牌时必须使用
存储需要在客户端读取的数据，如用户界面偏好（主题、语言）时，可以不带，让JS操作UI
####  Cookie 与 Web Storage (Local/Session Storage)
Cookie：它的主要设计目的是在客户端与服务器之间自动传递数据。它的存储是为此服务的。
Web Storage (LocalStorage / SessionStorage)：它的主要设计目的是在浏览器本地存储数据，这些数据不会自动发送给服务器。
#### cookie浏览器自动携带发送规则
cookie是否自动携带，只看“Domain+Path+Secure+SameSite”这套专属规则。也就是服务器setcookie时给这条cookie设置的属性。
而同源时，只是正好都满足上述的规则了，所以携带了，同源只是上述规则的一个子集而已。


### TLS及web加密安全的底层
#### 含义
TLS是SSL的迭代版本，是一种加密技术协议，用于将网络数据进行加密和解密的一些列操作流程规范
#### 现代密码学的底层哲学
算法是公开的，而密钥是私有的，如果是非对称加密，则公钥公开，私钥必须私有
加密和解密的过程就是，通过同一个算法，输入不同的密钥参数，同时输入明文（即使明文是一致的），可以得到不同的密文。
#### 公钥私钥的运作底层简析
以RSA为例，简单介绍
核心思想：基于“大数质因数分解”的极端困难性。即：将两个巨大的质数相乘很容易，但想将一个巨大的合数分解回原来的两个质数，在计算上是不可行的。
密钥生成：
  随机选择两个非常大的质数 p 和 q。
  计算它们的乘积 n = p * q。n 就是公钥和私钥中都包含的模数。
  计算一个函数 φ(n) = (p-1)(q-1)。
  选择一个整数 e，使得 1 < e < φ(n)，且 e 与 φ(n) 互质。(e, n) 就组成了公钥。
  计算一个整数 d，使得 (d * e) % φ(n) = 1。(d, n) 就组成了私钥。
  加密（用公钥）：
  假设明文消息是一个数字 m。
  加密过程：ciphertext = m^e % n
  公钥 (e, n) 是公开的，任何人都可以用这个公式进行计算，将明文 m 加密成密文 c。
解密（用私钥）：
  收到密文 c。
  解密过程：original_m = c^d % n
  神奇的事情发生了：(m^e % n)^d % n 通过数学推导（欧拉定理）可以证明正好等于原始的 m。
  而只有拥有私钥 (d, n) 的人才能进行这个计算。因为要从公开的 e 和 n 推导出 d，等价于要对 n 进行质因数分解得到 p 和 q，从而算出 φ(n)，这在计算上是不可行的。
  所以，公钥和私钥不是简单的字符串，而是一个包含特定数学关系的数字对。加密和解密是互逆的数学运算。
#### TLS的运作过程
![alt text](TLS协议运作过程.png)
1、客户端发送：支持的TLS版本号，一个随机数，支持的密码套件列表
2、服务器回应客户端，并发送一个消息：选择的TLS版本号，一个服务器生成的随机数，从客户端列表中选择的一个密码套件，服务器的CA数字证书
3、客户端验证证书与生成预主密钥
 1）客户端用根证书提供的CA公钥和指定的算法来验证服务器证书中CA证书签名值，得到一个哈希值H1；法进行对明文进行hash计算，得到H2；最后对比H1和H2，相同就是真证书，反之就是假的。
 2）证书有效的话，客户端就生成预主密钥（一个随机字符串）和证书提供的公钥进行加密，然后传给服务器
4、服务器用自己的私钥进行解密，得到预主密钥。
5、客户端和服务器各自用之前商议的算法对之前的两个明文随机数和保密的预主密钥进行PRF算法加密，得到“主密钥（会话密钥）”，后续用这个会话密钥进行AES的对称加密，用来加密大量传输的数据资源。
#### 总结核心点
TLS实际中，最起始的需要加密的就是预主密钥，保证不被窃取明文，后续针对预主密钥进行多次加工再使用。
针对RSA算法：公私密钥是一对参数，通过同一个算法，既可以得到密文，也可以得到明文。也就是签名和验签本质就是加密和解密。但是，这种“签名即加密”的观念不能推广到所有算法。对于ECC（椭圆曲线 cryptography） 等更现代的算法，数字签名算法（如ECDSA）和加密/密钥交换算法（如ECDH）是截然不同的。它们的数学原理和计算过程并不简单地是加密和解密的逆运算。
  ECDSA（签名）：生成签名的过程涉及产生一个随机数并进行一系列复杂的椭圆曲线运算，它不是简单地对哈希值用私钥进行“加密”。
  ECDH（密钥交换）：双方分别生成临时公私钥对，通过交换公钥并利用数学原理计算出一个共享秘密。这完全不是加密/解密的过程。

# 前端开发通用知识

## 浏览器

### 浏览器运行底层逻辑
#### 运行环境，如浏览器
浏览器是最顶点的处理系统，他有能力接收全部的代码，然后自己处理一部分（包裹dom，ui渲染，网络请求，计时器，事件循环调度），然js引擎仅仅是具体执行js代码的一个模块而已
#### js引擎，如v8
核心来说，就是js执行计算后，通过浏览器给的api去修改浏览器在内存中维护的dom/cssom而不是修改原始的html和css，然后浏览器发现维护的dom/cssom变化了，就触发重绘。
(1) V8 只负责 JS 执行，浏览器提供运行环境
  V8 无法直接操作 DOM，必须通过浏览器提供的 Web API（如 document.getElementById）。
  当 JS 调用 setTimeout 或 fetch 时：
    V8 解析代码，发现是异步 API，交给 浏览器线程池（如定时器线程、网络线程。
    浏览器在后台处理（计时/网络请求），完成后将回调推入 任务队列。
    事件循环 检查调用栈是否为空，如果是，则从队列取出回调交给 V8 执行。
(2) 渲染引擎与 JS 引擎互斥
  GUI 渲染线程 和 JS 引擎线程 是互斥的（不能同时运行）。
    如果 JS 长时间运行（如 while(true)），页面会卡住，因为渲染被阻塞。
    这也是为什么 Web Workers 被引入，让 JS 可以在后台线程运行，不阻塞主线程。

### 网页资源缓存
#### 强缓存
是什么？
  强缓存就像你给自己泡面设定了一个规则：“这碗面在下午3点前都是好的，3点前饿了就直接吃，不用问别人。” 在这个规则生效期内，浏览器根本不会发送请求到服务器，直接从本地磁盘或内存读取缓存。
通过什么字段判断？
  主要通过HTTP响应头中的这两个字段控制：
  Cache-Control (HTTP/1.1首选，优先级高)
    max-age=3600：缓存最多有效3600秒（1小时）。这是最常用的指令。
    no-cache：不是不缓存，而是禁用强缓存，每次使用前必须去服务器协商验证（即跳过强缓存，直接进入协商缓存）。
    no-store：真正的不缓存，完全不使用任何缓存，每次都要从服务器获取完整的响应。
    public：响应可以被任何中间代理、CDN和浏览器缓存。
    private：响应只能被用户的浏览器缓存，不允许任何中间代理缓存。
  Expires (HTTP/1.0的旧物，优先级低)
    值是一个绝对的过期时间（如 Expires: Wed, 21 Oct 2024 07:28:00 GMT）。
    缺点：依赖服务器和客户端时间严格同步，如果两者时间不同步，会导致缓存失效不准。
怎么用？
  服务器在返回资源时，在响应头中设置：Cache-Control: max-age=31536000, public # 缓存一年
  浏览器看到这个后，在一年内再次请求这个资源时，就会直接触发上图中的“强缓存”路径，完全不会产生网络请求（在Chrome DevTools的Network面板看到状态码为 200 (from disk cache)）。
#### 协商缓存
是什么？
  协商缓存就像你去超市买东西，结账时给店员看你的会员卡（缓存标识）。店员（服务器）会查一下系统（验证标识），然后告诉你：“你的卡没问题，可以继续用（304）”，或者“你的卡过期了，需要办张新的（200）”。这个过程一定会发生一次HTTP请求，但可能无需传输资源实体，从而节省带宽。
通过什么字段判断？
  通过两组请求头/响应头配对工作：
  ETag / If-None-Match
    服务器响应头 ETag：服务器给资源生成一个唯一标识符，类似于文件的指纹（如 ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"）。文件内容一变，ETag就变。
    浏览器请求头 If-None-Match：当强缓存过期后，浏览器会将之前收到的 ETag 值放在这个请求头里发给服务器。
    服务器比较当前的 ETag 和请求带来的 If-None-Match：
    匹配 -> 资源没变 -> 返回 304 Not Modified，body为空。
    不匹配 -> 资源变了 -> 返回 200 OK 和新的资源。
  Last-Modified / If-Modified-Since
    服务器响应头 Last-Modified：服务器告诉浏览器这个资源最后的修改时间（如 Last-Modified: Wed, 21 Oct 2024 07:28:00 GMT）。
    浏览器请求头 If-Modified-Since：浏览器将这个时间发给服务器。
    服务器比较当前的修改时间和请求带来的 If-Modified-Since：
      时间相同 -> 返回 304。
      时间不同 -> 返回 200 和新资源。
    缺点：精度只到秒，如果文件在1秒内改变，无法识别；有时候文件内容没变（如touch了一下），但修改时间变了，会导致缓存失效。
  ETag 比 Last-Modified 更精确，因此优先级更高，是现代Web开发的首选。
#### 使用场景
强缓存场景：适用于长期不会改变的静态资源。
  用法：给打包后带有哈希指纹的文件名（如 main.a1b2c3.js）设置超长的 Cache-Control: max-age=31536000（一年）。因为文件名变了就是新资源，旧资源可以永久缓存。
  好处：再次访问网站时，这些资源根本不会发起请求，速度极快。
协商缓存场景：适用于可能频繁变更的资源。
  用法：对HTML文件（或者不带哈希的URL）通常设置 Cache-Control: no-cache 或 max-age=0，让浏览器每次都去服务器协商验证。这样一旦HTML内容更新（从而引用了新的带哈希的JS/CSS），用户就能立刻获取到最新的版本。
  好处：既避免了客户端一直使用旧版本，又能在资源未变更时节省带宽。
总结一下配置策略：
  HTML文件：Cache-Control: no-cache （走协商缓存）
  带哈希的CSS/JS/图片：Cache-Control: max-age=31536000 （走强缓存）
  API接口：通常显式设置为 Cache-Control: no-store （敏感数据，完全不能缓存）或在响应中添加合适的缓存头。


### DOM相关
#### 节点类型
nodeType 属性是一个数字，用于表示节点的类型。它是最基础且可靠的区分节点类型的方法。
节点类型	值	常量 (示例)	描述
元素节点	1	Node.ELEMENT_NODE	
属性节点	2	Node.ATTRIBUTE_NODE	元素的属性，如 id="myId" (已废弃/不常用)
文本节点	3	Node.TEXT_NODE	元素内的文本内容，包括换行和空格
注释节点	8	Node.COMMENT_NODE	HTML 注释
文档节点	9	Node.DOCUMENT_NODE	document 对象本身
文档类型节点	10	Node.DOCUMENT_TYPE_NODE	
#### 获取节点的api
1. 获取相邻、父子元素 (遍历)
属性 / 方法	作用	返回	注意
parentNode	获取父节点	Node	可能是元素、文档或文档碎片
parentElement	获取父元素	Element	只返回元素类型的父节点
previousSibling	获取前一个兄弟节点	Node	可能是文本、注释节点
previousElementSibling	获取前一个兄弟元素	Element	常用，只忽略文本/注释节点
nextSibling	获取后一个兄弟节点	Node	可能是文本、注释节点
nextElementSibling	获取后一个兄弟元素	Element	常用，只忽略文本/注释节点
childNodes	获取所有子节点	NodeList	包含文本、注释等所有节点
children	获取所有子元素	HTMLCollection	最常用，只包含元素节点
firstChild	获取第一个子节点	Node	很可能是文本节点（换行/空格）
firstElementChild	获取第一个子元素	Element	常用
lastChild	获取最后一个子节点	Node	很可能是文本节点（换行/空格）
lastElementChild	获取最后一个子元素	Element	常用
简单总结：想要操作元素，就用带 Element 的那一套属性（如 children, previousElementSibling），这样可以避免文本节点的干扰。
2. 按条件获取元素 (选择)
方法	作用	返回	示例
getElementById()	通过 id 获取	单个 Element	document.getElementById('header')
getElementsByClassName()	通过 class 获取	HTMLCollection (动态)	element.getElementsByClassName('btn')
getElementsByTagName()	通过标签名获取	HTMLCollection (动态)	document.getElementsByTagName('div')
querySelector()	通过 CSS 选择器 获取第一个匹配项	单个 Element	document.querySelector('.container #user')
querySelectorAll()	通过 CSS 选择器 获取所有匹配项	NodeList (静态)	document.querySelectorAll('div.highlight')
querySelector 和 querySelectorAll 是现代前端开发中最强大和最常用的选择方法。

### 像素
#### dpr
物理像素(physical pixel)又可以称为设备像素(dp : device pixel)
CSS像素可称为来逻辑像素(logical pixel)，也可以称为设备独立像素(dip : device independent pixel)
dpr = 同一方向上的 物理像素 / CSS像素 (缩放比是1的情况)
dpr为1的就是标清屏，dpr > 1的就是高清屏
为了解决h5高清屏幕自动适应比例的问题，有如下办法：
使用viewport：width=device-width + rem尺度编码css
原理：设计稿宽度为Apx，查询到设备的宽度为Bpx。由于viewport中用了width=device-width，所以会将设计稿的全宽度Apx等比例变为等同于Bpx来显示整个页面。如果我的css代码中样式写的是固定的xpx的话，那么会出现，整个页面中的内容要么超出屏幕，要么比屏幕还要小，不能展示原设计稿的比例了。
而利用了将根元素的fonstsize也就是
```js
<script>
 document.documentElement.style.fontSize = (document.documentElement.clientWidth / (设计稿宽度 / 100)) + 'px';
</script>
```
动态计算后，得到了一个标尺，也就是设计稿中100px相当于现在设备完全显示时的多少px。从而在编码css时，只需要记住1rem就是设计稿的100px这个转换标尺即可。从而达成，页面能根据设备的实际宽度，自动调整比例，完美展示设计稿的布局。

### 浏览器block（阻塞）资源问题
什么是block：
  当浏览器原先访问的网页的协议是http或者https，而网页中的图片、视频资源（被动/显示型混合内容）url或者需要加载的js、css、字体、iframe、异步请求等（主动型混合内容）是不同的协议时，会破坏整个页面的安全性，形成“混合内容mixed content”。
  由于被动型混合内容的风险等级较低，浏览器会默认加载显示，但是也会降低页面的安全性，会警告；
  而主动型混合内容的风险等级极高，浏览器会阻塞加载；
如何处理block：
  修改资源引用地址，让网页中的资源请求的协议与原网页的协议一致，将资源部署的服务器的协议与原网页一致。也就是完全避免mixedcontent的出现。
  服务器重定向，可以先向自己的同协议服务器请求资源，然后由自己的服务器进行代理请求第三方资源后返回结果。其实是让浏览器无法发现mixed content，但是会加大自己服务器的任务量。
  根治方案 - 使用Content Security Policy (CSP)：CSP是一个额外的安全层，你可以通过HTTP响应头来告诉浏览器允许加载哪些来源的资源。服务器可以返回这样一个响应头：Content-Security-Policy: upgrade-insecure-requests 。浏览器会自动将页面中所有通过HTTP加载的资源的请求，统统升级为HTTPS请求后再发出。这对于修复一个拥有大量老旧HTTP资源链接的大型网站非常有用。但是如果第三方没有升级支持https，那么这个资源会加载失败。
  总结：优先统一协议，从源头处理；然后CSP过渡；最后用反向代理去处理个别不支持https的第三方资源。
  
### error报错相关
#### Script error.报错但是无详细错误信息
核心原因：跨域脚本与CORS
  当你的网页（https://your-site.com）引入了一个来自不同源（不同域名、协议或端口）的JavaScript文件（<script src="https://cdn.other-site.com/library.js">）时，如果这个外部脚本内部发生错误，浏览器默认只会向你的 window.onerror 回调报告一个模糊的 Script error.，而不会包含具体的错误信息、行号、堆栈等细节。
  浏览器这么做的目的是为了防止信息泄露。 详细的错误信息可能包含该第三方脚本的内部逻辑、数据结构或其他敏感信息，这些信息不应该被宿主页面（你的网站）所获取。
如何获取详细信息：
  第1步：为第三方脚本添加 crossorigin 属性
    在你的HTML中引入第三方脚本的标签上，添加 crossorigin="anonymous" 或 crossorigin="use-credentials" 属性。
    ```JS
    <!-- 修改前 -->
    <script src="https://cdn.other-site.com/library.js"></script>

    <!-- 修改后 -->
    <script src="https://cdn.other-site.com/library.js" crossorigin="anonymous"></script>
    ```
    crossorigin="anonymous"：最常用的选项。表示以匿名模式发起跨域请求（即不会随请求发送Cookie、客户端SSL证书等凭据）。
    crossorigin="use-credentials"：如果访问该脚本需要凭据（如Cookie），则使用此选项。但这要求服务器也必须响应 Access-Control-Allow-Credentials: true。
    这个属性的作用：它告诉浏览器，“请以跨域模式去获取这个脚本资源”。浏览器在发起请求时，会在HTTP头中带上 Origin: https://your-site.com。
  第2步：配置第三方服务器的CORS响应头
    光浏览器请求了还不够，第三方资源的服务器（cdn.other-site.com）必须在响应中明确允许你的网站获取错误详情。
    服务器需要在返回JS文件的响应头中设置：
    Access-Control-Allow-Origin: https://your-site.com
    或者，如果允许所有网站获取，则设置为：
    Access-Control-Allow-Origin: *
  只有同时满足了以上两个条件，浏览器才会认为这次跨域资源加载是经过授权的，从而在发生错误时，将完整的错误信息（错误消息、文件名、行号、列号、错误堆栈）透露给你的 window.onerror 处理函数。

## 移动端

### 移动端开发
#### 开发模式分类
Native App
  传统的原生App开发模式，有iOS和aOS两大系统，需要各自语言开发各自App。
  优点：性能和体验都是最好的。
  缺点：开发和发布成本高。
  应用技术：Swift，OC，Java。
WebApp
  移动端的网站，常被称为H5应用，说白了就是特定运行在移动端浏览器上的网站应用。一般泛指 SPA(Single Page Application)模式开发出的网站，与MPA（Multi-page Application）对应。
  优点：开发和发布成本最低。
  缺点：性能和体验不能讲是最差的，但也受到浏览器处理能力的限制，多次下载同样会占用用户一定的流量。
  应用技术：ReactJS，RegularJS，VueJS等等。
Hybrid App
  混合模式移动应用，介于Web App、Native App这两者之间的App开发技术，兼具“Native App良好交互体验的优势”和“Web App跨平台开发的优势”（百度百科解释）
  主要的原理是，由Native通过JSBridge等方法提供统一的API，然后用Html+Css实现界面，JS来写逻辑，调用API，最终的页面在Webview中显示，这种模式下，Android、iOS的API一般有一致性，Hybrid App所以有跨平台效果。
  优点：开发和发布都比较方便，效率介于Native App、Web App之间。
  缺点：学习范围较广，需要原生配合。
  应用技术：PhoneGap，AppCan，Wex5，APICloud等。
React Native App
  Facebook发现Hybrid App存在很多缺陷和不足，于是发起开源的一套新的App开发方案RN。使用JSX语言写原生界面，js通过JSBridge调用原生API渲染UI交互通信。
  优点：效率体验接近Native App，发布和开发成本低于Native App。
  缺点：学习有一定成本，且文档较少，免不了踩坑。
Weex App
  阿里巴巴开发团队在RN的成功案例上，重新设计出的一套开发模式，站在了巨人肩膀上并有淘宝团队项目做养料，广受关注，2016年4月正式开源，并在v2.0版本官方支持Vue.js，与RN分庭抗礼。
  优点：单页开发模式效率极高，热更新发包体积小，并且跨平台性更强。
  缺点：刚刚起步，文档欠缺；社区没有RN活跃，功能尚不健全，暂不适合完全使用Weex开发App。
#### UIWebView 和 WKWebView
1. 概览：
是什么：UIWebView 和 WKWebView 是iOS SDK中的类（组件）。开发者可以将它们像一块“画布”一样添加到App的界面里。
有什么用：在这块“画布”上，可以加载并显示网页内容（HTML, CSS, JavaScript）。这让App不再只是一个纯粹的原生应用，而是可以混合Web技术。
2. 使用场景
1）内嵌活动页/运营页：App中经常变化的板块，如活动公告、促销页面、新闻文章。用WebView加载可以做到动态更新，无需用户下载整个App新版本。后端修改HTML内容，App里的页面立即改变。
2）功能模块：App的某些完整功能模块直接用Web技术开发，例如：
  一些电商App的商品详情页。
  复杂的问卷、表单填写页面。
  金融类App的基金、股票详情页。
3）整个App的容器：使用像 Cordova / Ionic / Capacitor 这样的框架，整个App的界面几乎全部由WebView承载，通过框架提供的插件调用手机原生功能（相机、GPS等）。这类App被称为Hybrid App（混合应用）。
4）加载第三方Web内容：在App内直接显示第三方网站或服务，例如显示社交媒体授权登录页面、支付网关页面、地图服务等。
3. 差异
UIWebView 是iOS 2就出现的古老组件，而 WKWebView 是iOS 8推出的现代化替代品。Apple已经从iOS 12开始正式弃用UIWebView，现在开发必须使用 WKWebView。
特性	UIWebView (已弃用)	WKWebView (现代标准)	影响与说明
性能	性能差，运行在App主进程，耗内存，容易导致App卡顿或崩溃。	性能极佳，运行在独立的原生进程（与Safari相同）。即使网页内容崩溃，也不会导致你的整个App崩溃。	最核心的区别。WKWebView的JavaScript执行速度、页面渲染速度远超UIWebView，用户体验流畅得多。
JavaScript引擎	使用老旧的JavaScript引擎。	使用与Safari相同的 Nitro 引擎，JS执行效率提升数倍。	对于复杂的前端应用，性能差距天壤之别。
内存占用	内存占用高，且不会主动释放。	内存占用低，有高效的内存管理。	使用UIWebView的App更容易因内存占用过高而被系统强制终止。
与Native交互	通过笨重的 stringByEvaluatingJavaScriptFromString: 方法调用JS，效率低。	提供高效、现代的 evaluateJavaScript: 方法，并支持消息处理器（MessageHandler） 进行双向通信。	WKWebView与原生代码的交互更简单、更强大。
功能特性	功能简单，不支持许多现代Web API。	支持更多HTML5特性，如视频全屏播放、本地存储改进等，更接近Safari的能力。	WKWebView能更好地支持现代网页应用。
缓存机制	缓存机制不清晰，难以管理。	提供更精细的缓存控制（磁盘、内存缓存策略）。	WKWebView对网络资源的控制力更强。
4. 总结
WKWebView 是一个运行在独立进程、性能更强、更稳定、更现代的“迷你Safari浏览器”，是当前在iOS应用中嵌入Web内容的唯一正确选择。
#### 混合开发
##### 常用框架：
现在混合开发框架主要分为两大流派：
编译型原生框架（最流行）：
  原理：你用JavaScript/ Dart编写代码，但框架在打包时会将你的组件编译成真正的原生组件（iOS的UIView、Android的View）来渲染。它不是运行在WebView里的。
  代表：
  React Native (RN)：使用JavaScript和React语法。Facebook开源，社区庞大，生态成熟。是目前最流行的选择之一。
  Flutter：Google出品，使用Dart语言。性能极佳，渲染引擎自绘，能保证不同平台上极高的UI一致性。近年来发展非常迅猛，是RN的强大竞争者。
WebView型框架：
  原理：正如你理解的，整个App就是一个内置的浏览器（WebView）。UI全部用HTML/CSS/JS来渲染，通过一个“桥”来调用原生功能。
  代表：
  Capacitor (推荐)： Ionic团队推出的现代框架，旨在取代Cordova。API设计更现代化，对PWA项目迁移友好。
  Cordova (及其衍生版PhoneGap)：老牌框架，开创了Hybrid的时代，但现在逐渐被Capacitor取代。
  Ionic：它本身是一个UI组件库，通常需要与Capacitor或Cordova搭配使用，提供一套仿原生的UI体验。
总结：
1）混合开发的两大流派中，webview型的，更原始一些，开发者需要对JS桥通讯相关的api处理更熟练。而React native属于高级框架了，在这个框架下编写代码，集成度更高，开发者不需要使用原生的js桥相关的api注册和调用了，直接用RN框架提供的api即可调用原生的api并得到返回的结果用于js后续的流程。
2）两种模式各自有自己的使用场景。对于新项目，如果想用一套代码开发高质量App，通常会在 React Native 和 Flutter 之间做选择。而 Capacitor 则非常适合希望将现有Web项目快速打包成App的场景。
##### native与js通讯
底层：工作方式就是一套严格的“JSON RPC（远程过程调用）”协议。与axios异步调用服务端api的原理极其类似。
整个流程的核心是序列化 -> 异步消息传递 -> 反序列化。
1. 序列化（JS -> Native）：当你在JS端调用一个原生模块的方法时（如Camera.takePicture()），RN框架会将这个调用请求序列化成一个JSON消息。这个消息通常包含：
```json
{
  "module": "Camera",       // 要调用哪个原生模块
  "method": "takePicture",  // 要调用该模块的哪个方法
  "params": {               // 调用参数
    "quality": 0.8
  },
  "callbackId": 123         // 用于标识本次调用的唯一ID，以便后续接收回调
}
```
2. 异步消息传递：这个JSON字符串通过唯一的、共享的通信通道（在iOS上是WKScriptMessageHandler，在Android上是addJavascriptInterface）从JS线程（WebView）发送到原生主线程。
3. 反序列化与执行（Native端）：原生端的“桥”接收到这个消息后，解析JSON，找到对应的Camera原生模块，调用它的takePicture方法，并传入参数。
4. 返回结果（Native -> JS）：原生方法执行完毕后（比如拍完照拿到了图片路径），原生“桥”会再将结果序列化成一个JSON消息，通过通信通道发回JS端。
```json
{
  "result": {                 // 执行结果
    "uri": "file:///path/to/image.jpg",
    "width": 1080,
    "height": 1920
  },
  "error": null,              // 如果出错，这里是错误信息
  "callbackId": 123           // 对应之前发送的调用ID
}
```
5. JS处理结果：JS端的“桥”根据callbackId找到最初发起调用时设置的Promise或回调函数，将结果传递给它，从而完成整个异步调用。
所以，整个流程可以总结为：一个异步的、基于JSON的RPC协议。 这也解释了为什么所有从JS到Native的调用都是异步的，因为消息传递本身就是异步的。
6. 双端互调的使用场景
1）js调用native
通常是“请求一个服务或执行一个动作”（如拍照、读写文件）
2）Native调用JS
通常是“通知一个事件或返回一个结果”（如网络断了、照片拍好了、该渲染新界面了）
  返回异步操作的结果（最主要）：正如上面所述，用于将原生模块处理的结果返回给JS端的Promise或回调函数。
  发送事件/通知（非常常见）：Native端可以主动向JS端发送事件，而无需JS先请求。例如：
    设备状态变化：网络状态从WiFi变为4G、电量低、耳机插拔。
    系统事件：应用即将进入后台、应用从后台唤醒、收到推送通知。
    原生模块发起：一个后台播放音乐的原生模块，需要通知JS当前播放的进度。
    第三方SDK回调：例如，微信登录SDK在完成后，需要通过原生端将结果通知给JS。
  渲染指令（Flutter/RN核心机制）：对于React Native/Flutter，最核心的Native->JS调用是渲染UI。当需要更新界面时（例如由于状态改变），原生端会调用JS端的渲染方法（如React的render方法），JS计算好新的虚拟DOM或Widget树描述后，再通过“桥”将差异发送回原生端进行渲染。这是一个非常高频的调用。
7. 通讯代码案例
一、iOS (Swift + WKWebView)
1. Native端：注册一个供JS调用的模块
```swift
// 1. 创建实现消息处理的类
class NativeBridge: NSObject, WKScriptMessageHandler {
    // 2. 实现协议方法，当收到JS消息时触发
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        // 3. 判断消息名是否为约定的"getAppVersion"
        if message.name == "getAppVersion" {
            // 4. 获取App版本号 (Native逻辑)
            let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "Unknown"
            
            // 5. 将结果回调给JS
            // message.body 是JS传过来的参数
            // 通过evaluateJavaScript执行JS代码，调用JS端预先留好的回调函数
            if let webView = message.webView {
                let jsCode = "window.receiveAppVersion('\(version)')"
                webView.evaluateJavaScript(jsCode, completionHandler: nil)
            }
        }
    }
}

// 在ViewController设置WebView时
override func viewDidLoad() {
    super.viewDidLoad()
    
    let webView = WKWebView(frame: .zero)
    let contentController = webView.configuration.userContentController
    
    // 6. 将NativeBridge实例注册到WebView中，并指定JS端发送消息时的对象名 "NativeBridge"
    contentController.add(NativeBridge(), name: "getAppVersion") 
    
    // 加载网页
    webView.load(URLRequest(url: URL(string: "https://your-website.com")!))
}
```
2. JS端：调用Native方法
```html
<script>
// 7. 定义接收Native回调的全局函数
window.receiveAppVersion = function(version) {
    console.log('App Version is:', version);
    document.getElementById('version').innerText = version;
};

// 8. 发起调用：通过webkit.messageHandlers发送消息
function getVersion() {
    // 这行代码会触发Native端的 userContentController(_:didReceive:) 方法
    window.webkit.messageHandlers.getAppVersion.postMessage(null);
}
</script>

<body>
    <button onclick="getVersion()">获取App版本</button>
    <p>版本号: <span id="version"></span></p>
</body>
```
iOS流程小结：
  JS调用 window.webkit.messageHandlers.{NAME}.postMessage()
  Native在 userContentController(_:didReceive:) 方法中拦截并处理。
  Native处理完后，通过 webView.evaluateJavaScript() 回调JS中的函数。

二、Android (Kotlin + WebView)
1. Native端：注册一个供JS调用的模块
```kotlin
// 1. 创建供JS调用的类，并用@JavascriptInterface注解暴露方法
class NativeBridge(private val context: Context) {
    
    @JavascriptInterface
    fun getAppVersion(): String {
        // 2. 获取App版本号 (Native逻辑)
        return try {
            val pInfo = context.packageManager.getPackageInfo(context.packageName, 0)
            pInfo.versionName ?: "Unknown"
        } catch (e: Exception) {
            "Unknown"
        }
    }
}

// 在Activity中设置WebView
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    val webView = WebView(this).apply {
        settings.javaScriptEnabled = true // 必须开启JS
        
        // 3. 将NativeBridge类的一个实例注入到WebView中
        // 并指定在JS中暴露的对象名为 "AndroidNative"
        addJavascriptInterface(NativeBridge(this@MainActivity), "AndroidNative")
        
        loadUrl("https://your-website.com")
    }
}
```
2. JS端：调用Native方法
```html
<script>
function getVersion() {
    // 4. 直接调用被注入的全局对象 AndroidNative 上的方法
    // 注意：因为方法是同步的，可以直接获取返回值
    const version = AndroidNative.getAppVersion();
    console.log('App Version is:', version);
    document.getElementById('version').innerText = version;
}
</script>

<body>
    <button onclick="getVersion()">获取App版本</button>
    <p>版本号: <span id="version"></span></p>
</body>
```
Android流程小结：
  Native使用 addJavascriptInterface() 将一个Java/Kotlin对象注入到JS的全局上下文中。
  JS直接调用这个全局对象上的方法（如 AndroidNative.getAppVersion()），看起来像是调用一个本地同步函数。
  方法的返回值直接就是Native端返回的值。

三、总结
1. 作为web开发，需要的就是跟app开发者协商好具体需要注册的方法名和内容，然后我在js中调用native注册的方法，同时接收结果继续处理。
2. ios和aos与js通讯的差异：
  ios的中：js的调用和接收结果是分开的异步的，js只是给native发送了要调用的方法的字符串，实际还是native识别字符串后自己调用api，然后native继续发送json给js去触发调用了js注册在window上的函数。
  aos中：是js直接调用native暴露的api，且由js自己继续调用后续的处理结果。

### 异形屏适配
#### iewport Meta 标签增强
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
```
viewport-fit=cover：关键属性，让内容延伸到安全区域外（覆盖刘海和圆角）。
作用：避免默认的 auto 模式导致内容被刘海遮挡
#### CSS 安全区域常量（Safe Area Insets）
```css
body {
  /* 通过 CSS 变量或常量适配 */
  padding-top: env(safe-area-inset-top);    /* 顶部刘海高度 */
  padding-bottom: env(safe-area-inset-bottom); /* 底部 Home 条高度 */
  padding-left: env(safe-area-inset-left);   /* 左侧安全区域（横屏时） */
  padding-right: env(safe-area-inset-right); /* 右侧安全区域（横屏时） */
}
```
env()：iOS 11+ 提供的环境变量，动态返回安全区域间距。
#### 关键 UI 避让策略
顶部导航栏
```css
.navbar {
  padding-top: max(12px, env(safe-area-inset-top));
}
```
底部操作栏
```css
.toolbar {
  padding-bottom: max(16px, env(safe-area-inset-bottom));
}
```
#### JavaScript 动态检测
```js
// 检测是否为异形屏
const isNotched = () => {
  return CSS.supports('padding-top', 'env(safe-area-inset-top)');
};

// 动态调整布局
if (isNotched()) {
  document.documentElement.classList.add('notched-display');
}
```
#### 总结
必做项：
添加 <meta name="viewport" content="viewport-fit=cover">。
使用 env(safe-area-inset-*) 设置关键间距。



## JS相关

### JS内置数据结构容器
1. Array (数组)
最基础、最常用的线性数据结构。
用途：存储有序的元素集合。
特点：
可以存储不同类型的元素。
长度动态可变。
通过数字索引（从0开始）进行高效随机访问。
常见操作：push, pop, shift, unshift, slice, splice, map, filter, reduce 等。
2. Object (对象)
用途：存储键值对（Key-Value Pairs）集合。是 JavaScript 中最基础的数据结构。
特点：
键（Key）必须是字符串或 Symbol 类型。
无法直接保证属性的顺序（虽然现代引擎通常会按添加顺序维护，但依赖顺序是不安全的）。
原型链继承可能会带来意外的属性。
局限：在过去，Object 被用来模拟 Map 和 Set 的功能，但现在有了更专业的替代品。
3. Map (映射)
ES6 新增，专门用于存储键值对的“现代化”对象。
用途：比 Object 更专业的键值对集合。
特点（与 Object 对比）：
键可以是任意类型（对象、函数、基本类型都可以，而 Object 的键只能是字符串或 Symbol）。
键值对顺序是可靠的（遍历顺序就是插入顺序）。
性能更优 在频繁增删键值对的场景下。
大小易获取：直接通过 size 属性。
默认不包含任何键，无原型链干扰。
常见操作：set(key, value), get(key), has(key), delete(key), clear(), size。
4. Set (集合)
ES6 新增，用于存储唯一值的集合。
用途：自动去重的数组。成员的值都是唯一的，没有重复。
特点：
你观察得很对！它的内部实现机制确实类似于一个只有键、没有值的 Map（值被统一设置为一个固定的占位符）。所以它的特性与 Map 非常相似：值可以是任意类型、顺序即插入顺序、性能优异。
判断值是否相等的算法与 === 类似，但认为 NaN 等于自身（NaN !== NaN 为 true，但 Set 认为它们是同一个值）。
常见操作：add(value), has(value), delete(value), clear(), size。
5. WeakMap 和 WeakSet
它们是 Map 和 Set 的“弱引用”版本，专门用于解决特定场景（如内存泄漏）的问题。
特点：
弱引用：键/值必须是对象，且对这些对象的引用是“弱”的。这意味着如果该对象在其他地方没有被引用，它可以被垃圾回收机制回收，即使它在 WeakMap/WeakSet 中。
不可枚举：正因为键是弱引用，你无法获取其大小或遍历它们。
用途：
WeakMap：常用于存储对象的私有数据或元数据，而不用担心内存泄漏。例如，DOM 节点作为键，相关的数据作为值。
WeakSet：常用于标记对象。例如，用来检查一个对象是否已经被处理过。

### JS类型检查方法
#### 对比
方法	优点	缺点	主要用途
typeof	使用简单，对基本类型判断友好	对 null 和 Array 的 bug	快速区分基本类型（除null）和函数
instanceof	检查原型链，适用于自定义对象	无法跨域/iframe，基本类型无效	判断对象是否为某个构造函数的实例
Object.prototype.toString.call()	最精确、最通用	语法稍显复杂	精确判断所有内置类型
Array.isArray()	简单、可靠	仅用于数组	专用于判断数组
constructor	直观	可被修改，不安全	快速检查（需确保constructor未被修改）
#### 举例
```js
// typeof 操作符 最基础的方法，但对于引用类型（如数组、对象、null）的判断能力很弱。
console.log(typeof 42);          // "number"
console.log(typeof 'blubber');   // "string"
console.log(typeof true);        // "boolean"
console.log(typeof undefined);   // "undefined"
console.log(typeof function(){}); // "function" (特别好用!)

// 著名的坑
console.log(typeof null);        // "object" (BUG!)
console.log(typeof []);          // "object" (无法区分数组和普通对象)
console.log(typeof {});          // "object"

// instanceof 操作符 检查构造函数的 prototype 属性是否出现在对象的原型链上的任何位置。
// 自定义构造函数
class Animal {}
class Dog extends Animal {}

let myDog = new Dog();

console.log(myDog instanceof Dog);     // true
console.log(myDog instanceof Animal);  // true (因为它继承自Animal)
console.log(myDog instanceof Object);  // true (所有对象都继承自Object)

// 对基本类型无效
console.log('hello' instanceof String); // false
console.log(new String('hello') instanceof String); // true

// 数组的特殊情况
console.log([] instanceof Array);      // true
console.log([] instanceof Object);     // true (因为 Array.prototype.__proto__ 指向 Object.prototype)

// Object.prototype.toString.call() - 终极武器
// 这是最可靠、最精确的判断方法。它返回一个格式为 [object Type] 的字符串，其中 Type 是内部类型。
// 基本类型
Object.prototype.toString.call(42);        // "[object Number]"
Object.prototype.toString.call('str');     // "[object String]"
Object.prototype.toString.call(true);      // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null);      // "[object Null]" (完美解决了typeof的bug!)

// 引用类型
Object.prototype.toString.call([]);        // "[object Array]"
Object.prototype.toString.call({});        // "[object Object]"
Object.prototype.toString.call(new Date()); // "[object Date]"
Object.prototype.toString.call(/regex/);   // "[object RegExp]"
Object.prototype.toString.call(function(){}); // "[object Function]"

// 自定义对象（通常只会返回 [object Object]）
class MyClass {}
Object.prototype.toString.call(new MyClass()); // "[object Object]"
```


### 判断JS的运行环境
1. 判断是否在浏览器主线程环境
```js
// 方法一：检查 window 和 document 对象（最可靠）
const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

// 方法二：检查 navigator 和 location 对象（辅助判断）
const isBrowserAlt = typeof navigator !== 'undefined' && typeof location !== 'undefined';
```
2. 判断是否在Node.js环境
```js
// 方法一：检查 process 对象及其特有属性
const isNode = typeof process !== 'undefined' && process.versions && process.versions.node;

// 方法二：检查全局对象 global（但注意在浏览器中window也可能被篡改）
// const isNode = typeof global !== 'undefined' && global.global === global;

if (isNode) {
    console.log('运行在Node.js环境中');
    console.log('Node版本:', process.versions.node);
    // 可以安全使用 require(), process, __dirname 等
}
```
3. 其他环境整体综合检查
```js
function getEnvironment() {
    // 1. 检查Node.js
    if (typeof process !== 'undefined' && process.versions && process.versions.node) {
        return {
            type: 'node',
            version: process.versions.node,
            electron: process.versions.electron ? process.versions.electron : false
        };
    }
    
    // 2. 检查Deno
    if (typeof Deno !== 'undefined' && Deno.version && Deno.version.deno) {
        return { type: 'deno', version: Deno.version.deno };
    }
    
    // 3. 检查Bun
    if (typeof Bun !== 'undefined' && Bun.version) {
        return { type: 'bun', version: Bun.version };
    }
    
    // 4. 检查Web Worker
    // 检查是否在Worker中：有 self 但没有 window 和 document
    if (typeof importScripts === 'function') {
        // 存在self且属于ServiceWorkerGlobalScope
        if (typeof ServiceWorkerGlobalScope !== 'undefined' && 
            self instanceof ServiceWorkerGlobalScope) {
            return { type: 'service-worker' };
        }
        return { type: 'web-worker' };
    }
    
    // 5. 检查浏览器环境（最后检查，因为其他环境可能有类似的全局对象）
    if (typeof window !== 'undefined' && typeof document !== 'undefined') {
        return { 
            type: 'browser',
            userAgent: navigator.userAgent,
            mobile: /Mobi|Android/i.test(navigator.userAgent)
        };
    }
    
    // 6. 检查React Native
    if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
        return { type: 'react-native' };
    }
    
    return { type: 'unknown' };
}

// 使用示例
const env = getEnvironment();
console.log('当前环境:', env);

switch (env.type) {
    case 'browser':
        console.log('在浏览器中，UserAgent:', env.userAgent);
        break;
    case 'node':
        if (env.electron) {
            console.log('在Electron中，Node版本:', env.version);
        } else {
            console.log('在纯Node.js中，版本:', env.version);
        }
        break;
    case 'web-worker':
        console.log('在Web Worker中');
        break;
    // ... 其他case
}
```
4. 整体对比：
环境	存在于	主要用途	关键能力	关键限制
浏览器 (主线程)	Chrome, Firefox, Safari, Edge 等	运行动态网页、交互式Web应用	DOM操作、BOM API、渲染UI	无法直接访问文件系统、操作系统API
Web Worker	浏览器标签页内	处理CPU密集型任务，不阻塞页面渲染	多线程计算、大数据处理	无法操作DOM、无法使用window、document
Service Worker	浏览器后台	代理网络请求、实现离线缓存、推送通知	缓存管理、离线体验、后台同步	无法操作DOM，是完全异步的事件驱动环境
Node.js	服务器（如AWS EC2）、本地开发机	构建服务器、命令行工具、后端API	文件I/O、网络I/O、访问系统资源	没有浏览器DOM环境（但可以模拟）
Electron 渲染进程	Electron 开发的桌面应用（如VSCode, Discord）	构建跨平台的桌面应用程序	同时拥有Node.js能力+浏览器DOM能力	应用打包体积较大
React Native	手机App（iOS, Android）	用JavaScript构建原生移动应用	调用原生手机组件（摄像头、GPS）	没有DOM，渲染的是原生UI组件
Deno / Bun	服务器、本地开发机（Node.js的现代替代品）	同Node.js，但更安全、更现代	同Node.js，内置测试、格式化等工具	生态系统相比Node.js较新

5. 分别简介：
1） Web Worker
  是什么：浏览器提供的“多线程”技术。允许你在网页后台开启新的线程来运行脚本，而不会阻塞主线程（UI线程）。
  存在于：浏览器内部，一个独立的线程中。
  用于：执行一些计算密集型任务，避免页面卡顿。例如：
  大量数据的排序、过滤、转换。
  复杂的图像处理（如滤镜、识别）。
  语法高亮、代码编译。
  特点：和主页面完全隔离，不能操作DOM，不能使用alert。通过 postMessage 方法与主线程通信。
2） Service Worker
  是什么：一种特殊的Web Worker，它更像一个位于浏览器和网络之间的代理服务器。
  存在于：浏览器后台，独立于网页。
  用于：打造离线Web应用（PWA）的核心技术。例如：
  离线缓存：可以把网站的关键资源（HTML, CSS, JS, 图片）缓存起来，下次没有网络时也能打开。
  网络代理：可以拦截和处理所有的网络请求，决定是从缓存返回还是去网络请求。
  后台推送：即使浏览器关闭，也能接收服务器的推送通知。
  特点：生命周期比单个页面长，可以控制多个页面。
3） Electron 渲染进程 (Renderer Process)
  是什么：Electron是一个用Web技术（HTML, CSS, JS）来构建桌面应用程序的框架。一个Electron应用由一个“主进程”和多个“渲染进程”组成。
  存在于：Electron开发的桌面应用内部，比如你正在使用的 VS Code、Discord、Slack、Figma（桌面版）等。
  用于：构建跨平台（Windows, macOS, Linux）的桌面应用。
  特点：每个渲染进程就是一个完整的Chromium浏览器实例，所以它既有所有浏览器API（DOM, window），又因为Electron的整合，拥有Node.js的能力（可以读写文件、调用系统API）。这是它最强大的地方。
4） React Native
  是什么：用JavaScript和React来编写真正原生移动应用的框架。
  存在于：iOS和Android手机App内部。
  用于：开发跨平台移动应用。例如：Facebook、Instagram、Airbnb等都使用过React Native。
  特点：没有DOM。你的JS代码里写的 <View>、<Text> 组件，最终会被翻译成iOS的UIView和Android的TextView等原生组件进行渲染，性能和体验比WebApp好很多。
5） Deno 和 Bun
  是什么：可以理解为 Node.js 的现代化替代品。它们的目标和Node.js一样——让JavaScript能在服务器端运行。
  存在于：服务器或你的开发机上。
  用于：和Node.js完全相同，写服务器、命令行工具等。
  特点：
  Deno：由Node.js之父创建，默认安全（需要显式授权才能访问文件网络）、内置TypeScript支持、兼容浏览器API。
  Bun：一个更快的全合一工具包，不仅是一个运行时，还内置了打包器、转译器、npm客户端等，性能极高。


### 判断浏览器类型
#### 区分 Android 和 iOS
```js
// 判断是否为 iOS 设备
const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

// 判断是否为 Android 设备
const isAndroid = /Android/i.test(navigator.userAgent);

// 更常用的方法是同时判断，因为有些浏览器在iOS上也会包含“Android”关键字（奇葩之处）
const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
const isAndroid = /Android/i.test(navigator.userAgent) && !/iPhone|iPad|iPod/i.test(navigator.userAgent);

// 使用示例
if (isIOS) {
    console.log('当前是 iOS 设备');
    // 调用iOS特有的API或下载App Store链接
} else if (isAndroid) {
    console.log('当前是 Android 设备');
    // 调用Android特有的API或下载应用市场链接
}
```
#### 区分是否在微信中
```js
// 判断是否在微信内置浏览器中
// 注意： 在微信的 userAgent 中，MicroMessenger 是一个关键且唯一的标识符。
const isWeChat = /MicroMessenger/i.test(navigator.userAgent);

if (isWeChat) {
    console.log('正在微信中浏览');
    // 在这里执行微信相关的逻辑，如隐藏下载链接、调用JS-SDK等
} else {
    console.log('不在微信中');
}
```

### Proxy原理

对于一个普通对象，如果它没有 xMethod 属性，你去调用 proxy.xMethod() 绝对会报错 TypeError: proxy.xMethod is not a function。

Proxy 的强大和特殊之处就在于，它根本不是一个普通对象。它颠覆了 JavaScript 默认的对象行为规则。

Proxy 的工作原理：虚拟对象与陷阱
你可以把 Proxy 实例想象成一个虚拟对象或者一个壳。这个壳本身是空的，它没有自己的任何属性。它的全部行为都由你提供的 handler（处理器对象） 来定义。

当你对 proxy 进行任何操作（比如读取属性 proxy.xMethod、设置属性 proxy.x = 1、检查属性 'x' in proxy）时，JavaScript 引擎不会去 proxy 自身上找，而是会去调用 handler 对象上对应的陷阱函数 (Trap)。

你对 proxy 的操作	引擎会去调用 handler 的陷阱函数
proxy.x (读取属性)	get(target, prop, receiver)
proxy.x = 1 (设置属性)	set(target, prop, value, receiver)
'x' in proxy (检查属性存在)	has(target, prop)
delete proxy.x (删除属性)	deleteProperty(target, prop)
Object.keys(proxy) (获取属性名)	ownKeys(target)
proxy() (调用代理对象)	apply(target, thisArg, argumentsList)
new proxy() (构造代理对象)	construct(target, argumentsList, newTarget)
解答你的问题：proxy.xMethod() 的执行流程
现在我们来一步步拆解 proxy.xMethod() 这行代码是如何执行的：

解析 proxy.xMethod:

引擎看到要读取 proxy 对象的 xMethod 属性。
它发现 proxy 是一个 Proxy 实例，于是不去 proxy 自身上找有没有 xMethod 这个属性。
取而代之，它去调用创建 proxy 时提供的 handler 对象上的 get 陷阱函数。
执行 get 陷阱:

get(target, prop, receiver) 函数被调用。
target: 是我们传入的原始对象 {xMethod: function(){...}, yMethod: function(){...}}。
prop: 是我们要访问的属性名，这里是字符串 'xMethod'。
我们的 get 函数开始工作：if (typeof target[prop] === 'function')。它发现 target['xMethod'] 确实是一个函数。
然后，它 return 了一个新的函数 function(...args) { ... }（这个新函数包含了切面逻辑和调用原始函数的代码）。
完成属性读取:
proxy.xMethod 这个表达式的值，就是上一步 get 陷阱函数返回的那个新函数。
至此，proxy.xMethod 这个操作成功了，它得到了一个函数值。
执行函数调用 ():
现在，引擎开始执行 (proxy.xMethod)()，也就是执行刚刚得到的那个新函数。
这个新函数内部的逻辑开始运行：执行 before 切面 -> 调用 target.xMethod.apply(target, args) -> 执行 after 切面 -> 返回结果。
对于 proxy.yMethod():
整个过程完全重复一遍。读取 proxy.yMethod 再次触发 get 陷阱，prop 这次是 'yMethod'。
get 函数检查 target['yMethod']，同样返回一个为 yMethod 量身定做的包装函数。
然后调用这个新函数。

关键总结
Proxy 本身是空的：它就像一个“万能壳”，自己没有属性，它的所有行为都是“装”出来的，是动态计算的。

get 陷阱是“万能答案生成器”：每当有人问这个壳：“你的 xMethod 是什么？”，这个壳就会转头去问 get 函数：“嘿，有人要 xMethod，我该怎么回答？” get 函数就现场编一个答案（一个函数）返回给它。

不会报错的原因：报错发生在“读取属性”阶段。普通对象读不到属性就返回 undefined，你再调用 undefined() 就会报错。而 Proxy 在“读取属性”这个阶段就被拦截了，get 陷阱总是可以返回一个值（无论是返回原始对象的属性，还是像我们这样返回一个自定义函数），因此读取阶段永远不会得到 undefined，后续的调用阶段自然也就不会报错。

所以，proxy.xMethod() 能成功执行，不是因为 proxy 有 xMethod，而是因为 proxy 的规则告诉我们，当有人试图读取任何属性时，都用一个函数来应答，这个函数在被调用时再去决定真正要做什么。这是一种极其强大的元编程能力。
#### 底层实现
Proxy 之所以能做到“访问任何属性都先经过 get”，并不是因为它是一个有特殊属性的普通对象，而是因为它根本就不是一个普通对象。它在引擎内部是一种特殊的存在。

底层原理：内部方法 (Internal Methods) 和陷阱 (Traps)
要理解这个，我们需要了解 JavaScript 引擎是如何处理对象的。

所有对象操作都映射到内部方法：
在 JavaScript 引擎（如 V8）底层，你对一个普通对象的所有操作，比如读取属性 (obj.x)、设置属性 (obj.x = 1)、调用方法 (obj.x())，最终都会被翻译成调用一组预定义的内部方法。

[[Get]](P, Receiver)：负责读取属性。

[[Set]](P, V, Receiver)：负责设置属性。

[[HasProperty]](P)：负责检查属性是否存在 (in 操作符)。

[[DefineOwnProperty]](P, Desc)：负责定义属性 (Object.defineProperty)。

...等等。

当你创建一个普通对象 {} 时，引擎就为它设置了这些内部方法的默认实现。

Proxy 重写了内部方法：
当你使用 new Proxy(target, handler) 时，引擎创建的不是一个普通对象，而是一个代理异质对象 (Proxy exotic object)。

这是最关键的一步：这个代理异质对象将其所有内部方法的实现，替换成了对 handler 中相应陷阱函数的调用。

当你执行 proxy.x 时，引擎调用的是代理异质对象的 [[Get]] 内部方法。

而这个被重写的 [[Get]] 方法的逻辑非常简单伪代码：

c
// 伪代码，示意代理异质对象的 [[Get]] 内部方法实现
Proxy.[[Get]](propertyName, receiver) {
    // 1. 检查 handler 中是否有 get 陷阱
    if (handler.hasTrap('get')) {
        // 2. 如果有，就调用用户提供的 get 陷阱函数
        return handler.get(this.target, propertyName, receiver);
    } else {
        // 3. 如果没有陷阱，就回退到默认行为：去 target 上获取
        return this.target.[[Get]](propertyName, receiver);
    }
}
直观比喻
你可以把这个过程想象成：

普通对象：就像一个自动售货机。你按下按钮“可乐”（属性名），它内部有固定的机械结构（内部方法）直接给你一罐可乐（属性值）。

Proxy 对象：就像一个售货机 + 后面坐着一个真人售货员。你按下按钮“可乐”，这个动作会先亮起一盏灯通知后面的售货员。售货员（handler）看到灯亮了（get 陷阱被触发），看了看你要什么（参数 prop），然后他可以选择：

从身后的仓库（target）里拿一罐可乐给你（默认行为）。

给你一罐雪碧（返回其他值）。

问你为什么要可乐，记录一下你的需求再给你可乐（执行切面逻辑）。

甚至不给你饮料，而是给你一个玩具（返回一个函数）。

这个“售货员”介入的机制，是在制造这台特殊售货机（创建 Proxy）时就被硬编码到它的每一个按钮里的。 这就是为什么你按任何一个按钮（访问任何属性），都会先通知到售货员。

技术实现层面
在引擎实现中（例如 V8），Proxy 对象有一个指向 target 的指针和一个指向 handler 的指针。它的内部方法表被指向一组特殊的、用于代理的实现函数。这些实现函数的工作就是：查找陷阱 -> 调用陷阱 -> 返回结果。

所以，Proxy 的能力是语言层面赋予的特权。它不是在 JavaScript 代码层面通过巧妙的技巧实现的，而是引擎本身为它开的后门，让它能拦截和重定义最基本的对象操作。这正是 元编程（Metaprogramming） 的含义——编写能够操作程序自身的代码。

总结一下：Proxy 对象在引擎底层是“异质”的，它重写了自己所有内部方法的实现，将这些内部方法都改造成了“先检查是否有用户定义的陷阱函数，有则调用，没有则调用目标对象的默认内部方法”。因此，对它的任何操作都会被拦截。这是一种由 JavaScript 引擎原生支持的、无法用纯 JavaScript 代码模拟的强大功能。
#### 是proxy利用了v8引擎操作对象的钩子函数，通过重写钩子，改变了对象读取属性的路径。
这种原理有点类似REACT和VUE的生命周期钩子，暴露给用户，让用户可以在特定的环节，做一些跟日常操作不一样的动作。

### Web Components
创建独立封装的 UI 组件（如按钮、下拉菜单），无需依赖第三方框架，无需额外库
但缺少响应式数据、虚拟 DOM 等能力
使用场景：需要跨框架复用的组件、追求轻量级、无依赖的项目
```js
 class MyCustomTag extends HTMLElement {
      constructor() {
        super();
        // 创建Shadow DOM（可选，但通常用于封装样式和结构）
        const shadow = this.attachShadow({ mode: 'open' });
        const div = document.createElement('div');
        div.textContent = '这是自定义标签的内容';
        shadow.appendChild(div);
      }
    }
    customElements.define('my-customtag', MyCustomTag);
    // 在body中可以用<my-customtag />调用
```

### Promise底层详解
1、promise创建后，管理内部的state状态，以及管理注册的then和catch回调函数，并暴露自己的resolve和reject给到创建时传入的函数。且创建时传入的函数调用暴露的resolve或者reject时，会改变state并执行注册的回调函数。
2、链式调用就是在注册的then回调中，继续返回一个新创建的promise即可，该promise会有自己的新的状态和后面注册的then函数。（如果 then 的回调未返回 Promise，返回值会自动包装成 Promise.resolve(value)）
3、then 是 Promise 实例的方法（定义在 Promise.prototype 上），new Promise会创建一个promise，然后直接调用.then()通用函数，这个函数将收到的回调函数，注册到之前的那个promise对象的属性中，并且返回一个新的promise供下一个.then注册回调。
4、Promise.all()核心逻辑
  接收一个 Promise 数组，返回一个新的 Promise。
  全部成功：当所有输入的 Promise 都 resolve 时，新 Promise 以数组形式返回所有结果。
  任一失败：如果有一个 Promise reject，立即终止并返回该错误。
  总结：Promise.all()是要把几个promise对象组成的数组的返回结果统一接收，每有一个promise被resolve了，就会把自己的结果写入新创建的这个大promise的临时res中，且只有所有promise都resolve了，才会调用这个大promise注册的then函数，并把刚刚的临时res作为结果数组传入，供统一处理加工。且不需要每个小promise单独处理自己的数据了。
```jsx
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    const results = new Array(promises.length); // 密集数组
    let completedCount = 0;

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(value => {
          results[index] = value; // 直接按索引赋值
          completedCount++;
          if (completedCount === promises.length) resolve(results);
        })
        .catch(reject);
    });

    if (promises.length === 0) resolve(results);
  });
}
```

### async、await底层实现
#### async/await 的工作流程
```jsx
async function foo() {
  console.log("A");
  await bar();      // <- 暂停点
  console.log("B");
}

function bar() {
  return new Promise(resolve => {
    console.log("C");
    resolve();
    console.log("F");
  });
}

console.log("D");
foo();
console.log("E");
```
输出顺序：D → A → C → F → E → B
同步执行 console.log("D");
调用 foo()，执行 console.log("A")（await 前的代码同步执行）;
执行 bar()，同步执行 console.log("C") 并返回一个 Promise;
resolve()立刻同步执行， 会立即改变 Promise 的状态（从 pending 变为 fulfilled），内部确实会“调用” then 回调，但不是直接执行，而是将其加入微任务队列。
输出F
await 检测到 Promise，暂停 foo 的执行，将控制权交还给外部;
同步执行 console.log("E");
微任务队列执行（Promise.resolve()），恢复 foo，执行 console.log("B");
#### Generator 基础：暂停与恢复执行
function* 和 yield 的本质
function*：定义一个 Generator 函数，它返回一个迭代器对象（而非直接返回值）。
yield：相当于代码的暂停点，每次执行到 yield 时会返回右侧的值，并暂停函数执行。
无 return 时：
当 Generator 函数执行到末尾（无更多 yield 或 return），next() 返回 { value: undefined, done: true }。
最后一个 yield 的 done 仍是 false，只有真正结束时 done 才为 true。
如果手动 return，则 value 为返回值；否则为 undefined。
底层本质还是登记yield和return后的语句到某个管理属性数组内，然后暴露一个next方法，让外界调用next()时，能控制内部的指标移动，从而达成运行每个yield或return登记过的方法
```jsx
function* gen() {
  const res1 =yield 1;  // Generator 的双向通信：yield 返回 { value, done } 给外部，但 yield 的返回值由下一个 next(value) 传入。
  console.log(res1);//6 yield 的返回值由下一次 next(value) 调用时传入的 value 决定。这是 Generator 的固定设计模式,通过 next(value) 实现外部向 Generator 内部传值的能力
  const res2 =yield 2;  // 暂停，返回 { value: 2, done: false }
  console.log(res2);//7

  return 3; // 结束，返回 { value: 3, done: true }
}

const g = gen();
console.log(g.next(5)); // { value: 1, done: false }
console.log(g.next(6)); // { value: 2, done: false }
console.log(g.next(7)); // { value: 3, done: true }
// 1. g.next(5) → 启动 Generator，执行到 yield 1，返回 { value: 1, done: false }（忽略参数 5）
// 2. g.next(6) → 将 6 赋给 res1，执行到 yield 2，返回 { value: 2, done: false }
// 3. g.next(7) → 将 7 赋给 res2，执行到 return 3，返回 { value: 3, done: true }

// 示例：Generator + Promise 模拟 async/await
function* asyncGenerator() {
  const result1 = yield Promise.resolve(1); // 暂停，等待 Promise 解决
  const result2 = yield Promise.resolve(2); // 再次暂停
  //这里不会继续返回了，而是直接加工前面的结果了
 console.log( result1 + result2)
}

// 自动执行器
// 核心：自动执行器通过 Promise.resolve(value).then(step) 递归驱动 Generator（将返回值包装为promise，并将下一次的next作为其then回调函数，就实现了必须等上一个next的promise被resolve后，才执行下一个next），并将 Promise 结果传回内部。
function runGenerator(gen) {
  const iterator = gen();
  // nextValue 的作用：当 yield 一个 Promise 时，Promise.resolve(value).then(step) 会等待 Promise 解决，并将结果通过 step(resolvedValue) 传回 Generator，赋值给 result1/result2。
  function step(nextValue) {
    const { value, done } = iterator.next(nextValue);
    // //反正之前的每一步next已经把yield的值返回给res接收了，最后返回了undefined也没事，没有人需要用这个值了，我只需要在前面asyncGenerator中处理所有接收到的res就行了
    if (done) return Promise.resolve(value);
    return Promise.resolve(value).then(step); // 递归处理下一个 yield
  }
  return step();
}

runGenerator(asyncGenerator)//输出 3，返回 Promise<undefined>,外部获取的 Promise 无具体值（但可知道何时完成）。

// 1. yield Promise.resolve(1) → 返回 { value: Promise(1), done: false }
// 2. Promise.resolve(1).then(step) → 微任务队列: step(1)
// 3. step(1) → iterator.next(1) → result1 = 1，继续执行到 yield Promise.resolve(2)
// 4. 循环直到 Generator 结束。
```

### form表单上传
不同于异步axios利用formdata自己加工数据然后上传至服务器地址
```js
// 文件选择元素->change改变事件
document.querySelector('.upload').addEventListener('change', e => {
  // 1. 获取图片文件（e.target就是input这个元素，含有一个属性叫files，是一个fileList对象。类似数组）
  // 可以用for (const file of curFiles) {遍历处理各个file对象}
  console.log(e)
  console.log(e.target.files[0])
  // 2. 使用 FormData 携带图片文件
  const fd = new FormData()
  fd.append('img', e.target.files[0])
  // 3. 提交到服务器，获取图片url网址使用
  axios({
    url: 'http://hmajax.itheima.net/api/uploadimg',
    method: 'POST',
    data: fd
  }).then(result => {
    console.log(result)
    // 取出图片url网址，用img标签加载显示
    const imgUrl = result.data.data.url
    document.querySelector('.my-img').src = imgUrl
  })
})
```
form表单上传，需要设置enctype="multipart/form-data"，作用是将表单数据分块编码，支持文件上传（支持同一个form内上传文件及key-value字段，后端可以根据req中不同属性获取不同的信息）
```html
<form action="/upload" method="post" enctype="multipart/form-data">
  <input type="file" name="file" />
  <button type="submit">上传</button>
</form>
```
enctype还有两个值
text/plain：数据以纯文本格式编码（极少使用）
application/x-www-form-urlencoded	：默认值，表单数据编码为 key=value&key=value 格式
#### 总结
分步提交（URL 嵌入） 是 Ant Design 推荐的最佳实践，尤其适合复杂表单。
直接提交（multipart/form-data）将文件负载到body中适合简单场景，减少请求次数。

### Object相关
1. Object.create() 的参数与原型链
参数：Object.create(proto, [propertiesObject])
proto：必需。新创建对象的原型对象。
propertiesObject：可选。一个对象，其自有可枚举属性将成为新对象的属性（类似于 Object.defineProperties 的第二个参数）。
传入 null 或 undefined 会怎样？
Object.create(null):
这是非常常见的用法！ 它会创建一个真正的空对象。
原型链：这个新对象没有原型（[[Prototype]] 为 null）。这意味着它不会继承任何来自 Object.prototype 的属性和方法（如 toString, hasOwnProperty, constructor 等）。
用途：常用作一个纯净的映射（Map），可以安全地存储任意键值而不用担心和原型上的属性名冲突（例如，你甚至可以存储一个键为 toString 而不会覆盖方法）。
Object.create(undefined):
这会抛出一个 TypeError。规范要求第一个参数必须是对象或 null。
产生的原型链是什么？
obj = Object.create(A)：obj.__proto__ === A （现代写法：Object.getPrototypeOf(obj) === A）
obj = Object.create(null)：Object.getPrototypeOf(obj) === null （原型链的终点）

2. Object.assign() 的用法与原理
主要用法：用于将所有可枚举的自有属性从一个或多个源对象复制到目标对象。它返回目标对象。
```js
const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3, b: 4 }; // 注意b会覆盖之前的

const result = Object.assign(target, source1, source2);
console.log(result); // { a: 1, b: 4, c: 3 }
console.log(target); // { a: 1, b: 4, c: 3 } (目标对象本身也被修改了)
```
原理（模拟实现）：
Object.assign 的本质是一个浅拷贝。它遍历所有源对象的可枚举自有属性，并用 = 赋值给目标对象。
```js
// 一个简单的polyfill原理
if (typeof Object.assign != 'function') {
  Object.assign = function(target, ...sources) {
    if (target == null) { // 检查null和undefined
      throw new TypeError('Cannot convert undefined or null to object');
    }
    const to = Object(target); // 将目标转换为对象

    for (const source of sources) {
      if (source != null) { // 过滤掉null和undefined源
        // 遍历源对象的所有自有、可枚举属性
        for (const key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            to[key] = source[key]; // 浅拷贝！
          }
        }
      }
    }
    return to;
  };
}
```
关键点：
浅拷贝：如果源对象的属性值是对象，拷贝的是引用。
不拷贝不可枚举属性和Symbol属性（ES6后来也支持拷贝Symbol属性了）。
会触发目标对象上的setter，但不会触发源对象上的getter或目标对象上的getter。

3. Object.defineProperty() 的用途与 frozen
有什么用？
用于直接在对象上定义一个新的属性，或修改一个现有属性，并精确地控制这个属性的行为。这是实现高级对象操作（如响应式、不可变数据）的基石。
你可以配置的属性描述符（Property Descriptors）主要有两种：
数据描述符：包含 value（值）, writable（可写？）, enumerable（可枚举？）, configurable（可配置？）
存取器描述符：包含 get（获取函数）, set（设置函数）, enumerable, configurable
```js
const obj = {};
Object.defineProperty(obj, 'key', {
  value: 'static',
  writable: false,    // 只读！
  enumerable: true,   // 可枚举
  configurable: false // 不可配置（不可删除，也不可再修改描述符）
});
obj.key = 'new value'; // 在严格模式下会报错，非严格模式下静默失败
console.log(obj.key); // 'static'
```
为什么要修改可枚举性 (enumerable)？
控制可见性：让某些属性在 for...in 循环或 Object.keys() 中“隐藏”起来。例如，对象的方法通常被设置为不可枚举，这样当你遍历对象时，不会把方法也遍历出来。
内部属性：模拟语言内部的、不希望被用户直接遍历到的属性。

frozen (冻结) 属性修改？
Object.freeze() 是一个更高级的操作，它调用 Object.defineProperty() 将对象的所有属性都设置为 writable: false, configurable: false，并且它还会阻止添加新属性。一旦冻结，无法解冻。
有什么库用了这些知识点？
Vue 2：其响应式系统的核心正是基于 Object.defineProperty() 的 getter/setter。Vue 遍历 data 对象的所有属性，将它们转换为 getter/setter，从而能够追踪依赖和触发更新。
Immutable.js / Immer：这些不可变数据库在实现时，会利用这些属性描述符来确保数据的不可变性。
各种ORM和模型库：用于定义模型的字段及其元数据。

4. 属性遍历：Object.keys() vs for...in & 可枚举性
可枚举性 (Enumerable) 是什么？
这是每个对象属性都有的一个内部标志（flag）。它决定了这个属性是否会被某些枚举性的操作所包含。
区别：
可枚举属性：会被 for...in、Object.keys()、JSON.stringify() 等操作包含。
不可枚举属性：不会被上述操作包含。大多数内置方法（如 Object.prototype.toString）都是不可枚举的。
如何获取不同范围的属性？
方法	获取范围	示例
Object.keys(obj)	自有、可枚举属性的键名（数组）	Object.keys({a:1}) // ['a']
for...in	可枚举属性的键名（包括继承的）	for (let key in obj) {}
Object.getOwnPropertyNames(obj)	所有自有属性的键名（包括不可枚举）	能获取到不可枚举的属性，如数组的 length
Object.getOwnPropertySymbols(obj)	所有自有 Symbol 属性的键名	
Reflect.ownKeys(obj)	所有自有属性的键名（包括Symbol和不可枚举）	Object.getOwnPropertyNames + Object.getOwnPropertySymbols

5. 如何检测一个属性是否可枚举？
使用 Object.prototype.propertyIsEnumerable() 方法。
```js
const obj = {};
Object.defineProperty(obj, 'hidden', {
  value: 'secret',
  enumerable: false
});
obj.visible = 'I am here';

console.log(obj.propertyIsEnumerable('visible')); // true
console.log(obj.propertyIsEnumerable('hidden')); // false
console.log(obj.propertyIsEnumerable('toString')); // false (因为toString是继承的，不是自有的)
```

6. Object.is() 有什么用？
它用来比较两个值是否严格相等。它和 === 几乎一样，但有两个著名的区别：
Object.is(NaN, NaN) returns true (而 NaN === NaN 返回 false)
Object.is(0, -0) returns false (而 0 === -0 返回 true)
它提供了一种比 === 更精确的、符合直觉的比较方式。ES6 引入它，很大程度上是为了让一些内部算法（如 Map 和 Set 的键比较）有更明确的行为。

7. 其他常用好用的静态方法
Object.values(obj) / Object.entries(obj) (ES2017):
```js
const obj = { a: 1, b: 2 };
console.log(Object.values(obj)); // [1, 2]
console.log(Object.entries(obj)); // [ ['a', 1], ['b', 2] ]
```
Object.fromEntries(iterable) (ES2019): 是 Object.entries 的逆操作。
```js
const entries = [ ['a', 1], ['b', 2] ];
console.log(Object.fromEntries(entries)); // { a: 1, b: 2 }
// 非常实用：将Map转为Object
const map = new Map([ ['a', 1], ['b', 2] ]);
console.log(Object.fromEntries(map)); // { a: 1, b: 2 }
```
Object.hasOwn(obj, propKey) (ES2022): 更安全地替代 obj.hasOwnProperty(prop)。
```js
const obj = Object.create(null);
obj.a = 1;
// obj.hasOwnProperty('a') // 报错！因为obj没有继承hasOwnProperty方法
console.log(Object.hasOwn(obj, 'a')); // true (完美)
```
Object.freeze(obj) / Object.seal(obj) / Object.preventExtensions(obj): 用于限制对象的可变性，层级依次降低（freeze最严格）。

### 动画的优化加速
#### 强制 GPU 加速
```css
.animated-element {
  transform: translateZ(0); /* 或 translate3d(0, 0, 0) 将动画元素提升至独立图层，避免与其他 DOM 一起重绘。 */
  will-change: transform;    /* 提前告知浏览器优化 */
}
```
#### 精简动画属性
```css
/* 避免动画中修改这些属性（触发重排/重绘） */
.animated-element {
  /* ❌ 避免 */
  transition: width 1s, height 1s, margin 1s;
  /* ✅ 推荐 */
  transition: transform 1s, opacity 1s;
}
```
仅动画 transform 和 opacity（复合层属性）。
#### 优化动画参数
```css
.animated-element {
  transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.4, 1);
  /* 使用贝塞尔曲线替代 linear/ease，减少卡顿感 */
}
```
Duration：控制在 300ms~500ms 之间（过久易卡顿）。
Timing Function：cubic-bezier() 比 ease-in-out 更流畅。
#### 改用 @keyframes 控制复杂动画
更精确控制每一帧，避免 transition 的不可预测性。
#### Opera 专项优化
检测浏览器并降级
```js
if (/opera/i.test(navigator.userAgent)) {
  document.documentElement.classList.add('opera-legacy');
}
```
```css
.opera-legacy .animated-element {
  animation: none; /* 降级为简单动画 */
  transition: opacity 0.3s; /* 仅保留淡入淡出 */
}
```

## CSS相关

### SASS LESS
#### 背景
在前端开发中，CSS 是网页设计的核心语言。然而，随着项目变得日益复杂，传统的 CSS 文件管理和维护困难，尤其是在大型项目中。为了提升 CSS 的灵活性、可维护性和可读性，CSS 预处理器应运而生，其中最流行的两种是 Sass 和 Less。
#### Sass 和 Less 的介绍
Sass（Syntactically Awesome Style Sheets）：Sass 是一种扩展了 CSS 的预处理器，提供了变量、嵌套、混合、继承等功能。Sass 有两种语法：一种是传统的 Sass（缩进式），另一种是 SCSS（类似于 CSS 的语法）。
Less：Less 是一个动态样式表语言，也扩展了 CSS，允许使用变量、嵌套、混合和函数。Less 的语法更接近 CSS，使用简单，易于上手。
#### 原理
Sass 的原理
编写 Sass 代码：开发者使用 Sass 或 SCSS 语法编写样式。
编译：使用 Sass 编译器将 Sass 代码编译成标准的 CSS。
输出 CSS：编译器输出的 CSS 文件可以被浏览器直接加载和使用。
Less 的原理
编写 Less 代码：开发者使用 Less 语法编写样式文件。
编译：使用 Less 编译器把 Less 代码转换为标准的 CSS。
输出 CSS：编译后的 CSS 文件可以直接安装在 HTML 文件中。
特点
#### Sass 的特点
变量：可以使用 $ 前缀定义变量，存储常用的颜色、字体等样式。
嵌套：支持选择器的嵌套，让样式层次关系更加清晰。
混合宏（Mixins）：允许将样式集合存储为可重用的函数。
继承：支持继承的特性，避免重复代码。
条件与循环：Sass 支持条件判断和循环功能，增强了逻辑处理能力。
#### Less 的特点
变量：使用 @ 前缀定义变量，功能与 Sass 的变量类似。
嵌套：支持选择器的嵌套，增强了样式的结构性。
混合（Mixins）：可定义可复用的样式组合，与 Sass 的混合功能相似。
运算功能：Less 支持基本的数学运算，如加减乘除。
易于学习：由于语法类似于 CSS，Less 对初学者更友好。
#### 代码案例
以下是 Sass 和 Less 的一个简单示例。
Sass 示例
目录结构：
your-style-lib/
├── _variables.scss    // 主题变量（颜色、间距等）
├── _functions.scss   // 工具函数
├── _mixins.scss      // 复用的 Mixin（动画、布局等）
├── _components.scss  // 组件样式（基于变量和 Mixin）
└── main.scss         // 主入口文件（@import 所有部分）

_variables.scss（定义变量）：
```scss
// 主题色
$colors: (
  primary: #3498db,
  success: #2ecc71,
  danger: #e74c3c
);

// 间距
$spacing-unit: 8px;
$spacings: (
  small: $spacing-unit,
  medium: $spacing-unit * 2,
  large: $spacing-unit * 4
);
```
_mixins.scss（定义混合宏）：
```scss
@mixin border-radius($radius) {
  -webkit-border-radius: $radius;
  -moz-border-radius: $radius;
  border-radius: $radius;
}
```
_functions.scss
```scss
// 获取颜色 + 透明度
@function color-with-alpha($name, $opacity: 1) {
  @return rgba(map-get($colors, $name), $opacity);
}
// 使用
.alert {
  background: color-with-alpha(success, 0.2);
}
```
main.scss（主样式文件）：
```scss
@import 'variables';
@import 'mixins';

body {
  font-family: $font-stack;
  background-color: $primary-color;

  h1 {
    color: white;
  }

  .button {
    @include border-radius(5px);
    background-color: darken($primary-color, 10%);
    padding: 10px 20px;
    color: white;
  }
}
```
Less 示例
my-project
└── styles
    ├── variables.less
    ├── mixins.less
    └── main.less
variables.scss（定义变量）：
```less
@primary-color: #3498db;
@font-stack: 'Helvetica', sans-serif;
```
mixins.scss（定义混合宏）：
```less
.border-radius(@radius) {
  -webkit-border-radius: @radius;
  -moz-border-radius: @radius;
  border-radius: @radius;
}
```
main.scss（主样式文件）：
```less
@import 'variables.less';
@import 'mixins.less';

body {
  font-family: @font-stack;
  background-color: @primary-color;

  h1 {
    color: white;
  }

  .button {
    .border-radius(5px);
    background-color: darken(@primary-color, 10%);
    padding: 10px 20px;
    color: white;
  }
}
```
#### 函数抽取典型场景
响应式断点管理
```scss
// _mixins.scss
@mixin respond-to($breakpoint) {
  @media (min-width: map-get($breakpoints, $breakpoint)) {
    @content;
  }
}

// 使用
.header {
  font-size: 16px;
  @include respond-to('md') { font-size: 18px; }
}
```
颜色处理
```scss
// _functions.scss
@function tint($color, $percentage) {
  @return mix(white, $color, $percentage);
}

.button {
  background: tint(#3498db, 10%); // 浅色 10%
}
```
动画复用
```scss
@mixin fade-in($duration: 0.3s) {
  animation: fadeIn $duration ease-out;
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
}

.modal {
  @include fade-in(0.5s);
}
```
#### 基础语法
@ 后常用关键字分类
流程控制（逻辑指令）：
@if	条件判断	@if $theme == dark { ... }
@else	条件分支	@else { ... }
@else if	多条件分支	@else if $size == large { ... }
@for	循环生成样式	@for $i from 1 through 3 { ... }
@each	遍历列表或映射	@each $color in $colors { ... }
@while	条件循环（较少用）	@while $i > 0 { ... }
代码复用（Mixin 相关）：
@mixin	定义可复用的代码块	@mixin button { ... }
@include	调用 Mixin	@include button;
@content	在 Mixin 中插入外部内容	@mixin hover { &:hover { @content } }
样式扩展与继承：
@extend	继承其他选择器的样式	.error { @extend .alert; }
@at-root	跳出嵌套，在根层级生成样式	@at-root { .global { ... } }
导入与模块化：
@import	导入其他文件（已逐步被 @use 取代）	@import 'variables';
@use	模块化导入（Sass 新规范）	@use 'utils' as u;
@forward	转发模块的变量和 Mixin	@forward 'buttons' as btn-*;
#### @mixin 和 @function 的核心区别
特性	@mixin	@function
返回值	返回一组 CSS 声明块（键值对）	返回单个值（如颜色、尺寸等）
调用方式	必须用 @include 调用	直接通过函数名调用（无需前缀）
使用场景	生成重复的样式块（如按钮、动画）	计算动态值（如颜色计算、单位转换）
编译结果	将混合的代码插入调用位置	返回的值需赋值给某个 CSS 属性
是否需属性接收	不需要（直接生成样式）	必须用于属性值（如 width: func();）


#### 编译
编译 Sass：
```bash
sass styles/main.scss styles/main.css
```
编译 Less：
```bash
lessc styles/main.less styles/main.css
```
#### 注意事项
选择合适的工具：根据团队的需求和熟悉程度选择 Sass 或 Less。Sass 的功能更丰富，适合复杂项目，而 Less 更具简洁性。
保持代码规范：无论是 Sass 还是 Less，编写样式时都应遵循代码规范，以提升可读性和可维护性。
避免过度嵌套：过度使用嵌套会造成 CSS 选择器过长，影响性能。因此，建议嵌套层级控制在 3 层以内。
模块化管理：对于大型项目，建议将样式分割成多个文件，以便管理和维护。
编译工具的选择：选择合适的编译工具，确保能够符合团队的工作流程。比如支持热重载的工具，可以大幅提高开发效率。
在现代前端开发中，Sass 和 Less 的使用使得开发者能够更加高效地管理和维护 CSS，提高工作效率。

### CSS UI库的设计思想
（如 Bootstrap、Ant Design、Tailwind CSS 或基于 Sass 的框架）
#### 原子化与组合思想
原子化 CSS（如 Tailwind）：将样式拆解为不可再分的单一功能类（如 .text-red-500、.p-4），通过组合类名快速构建 UI。
优势：极致复用、减少冗余 CSS，适合定制化场景。
组件化 CSS（如 Bootstrap/AntD）：提供预制的组件样式（如 .btn、.card），通过修改变量或覆盖样式实现定制。
优势：开箱即用，适合快速开发。
#### 分层架构
基础层（Base）：
重置浏览器默认样式（如 normalize.css），定义全局字体、颜色变量。
工具层（Utilities）：
提供原子类或工具函数（如间距、文本对齐）。
组件层（Components）：
封装完整的 UI 组件样式（按钮、表单等）。
主题层（Theme）：
通过变量或配置文件支持动态换肤。
#### 响应式设计
断点系统：
定义通用屏幕断点（如 sm: 576px），通过媒体查询或工具类适配。
#### 变量驱动
CSS 变量/Sass 变量：
将颜色、间距等抽象为变量，便于统一修改。
#### 性能优化
按需加载：
支持仅导入使用的组件（如 import { Button } from 'antd'）。
#### 命名规范
BEM（如 .block__element--modifier）、命名空间（如 AntD 的 ant- 前缀）。
#### 核心目标
通过原子化、标准化、复用性、可配置性，提升开发效率并保持视觉一致性。

### 伪元素伪类
#### 核心区别
维度	    伪类（如 :hover）	                        伪元素（如 ::before）
作用对象	选择元素的特定状态（如悬停、聚焦）	        在元素内创建虚拟的子元素（如前置内容）
语法标识	单冒号（:），CSS3 中部分伪类也支持双冒号	  双冒号（::），CSS3 规范要求
DOM 表现	不生成新元素，仅匹配已有元素的状态	        生成一个可样式化的虚拟元素（不在 DOM 中）
修改内容	无法直接插入内容，仅能修改已有内容的样式	    可通过 content 属性插入新内容
#### 为什么img不能有::before
替换元素特性：
img、input、video 等是替换元素（内容由外部资源决定），其内容不在 CSS 渲染范围内，因此无法通过伪元素插入内容。
逻辑矛盾：
伪元素需要依赖元素的文档流结构，而 img 的内容由 src 属性定义，无法容纳额外的子元素。
替代方案：用包裹容器实现类似效果
#### 典型案例
```css
/* 添加引号 */
.blockquote::before {
  content: open-quote;  /* 使用语言环境的开引号 */
  font-size: 2em;
  color: #999;
}
.blockquote::after {
  content: close-quote; /* 对应的闭引号 */
}
/* 自定义列表序号 */
ol.custom {
  counter-reset: item;  /* 初始化计数器 */
  list-style: none;
}
ol.custom li::before {
  content: counter(item) ") ";  /* 格式：1) 2) ... */
  counter-increment: item;
  color: #f06;
}
/* 使用 IconFont */
.button::after {
  content: "\f007";     /* Unicode 或字体图标代码 */
  font-family: "FontAwesome";
  margin-left: 5px;
}
/* 清除浮动 */
.clearfix::after {
  content: "";
  display: table;
  clear: both;
}
/* 实现 Tooltip */
.tooltip {
  position: relative;
  display: inline-block;
  cursor: pointer;
}

.tooltip:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  white-space: nowrap;
}
```
```html
<button class="tooltip" data-tooltip="点击提交">提交</button>
```
#### 总结
伪类：用于状态选择（如 :hover），不生成新元素。
伪元素：用于创建虚拟元素（如 ::before），可插入内容。
img 限制：作为替换元素，不支持伪元素（需用容器包裹）。
伪元素核心：
  必须定义 content 属性（空字符串 "" 也有效）。
  通过 position 控制布局，结合 attr() 动态获取数据。



## React

### 概念
基于虚拟 DOM 的声明式 UI 框架，提供状态管理、生命周期等高级功能
使用场景：复杂交互和状态管理（如单页应用）、需要生态支持（如 Redux、React Router）

### 底层架构全景图
组件树 → Fiber 树（链表结构，支持中断/恢复）
│
├─ 渲染阶段（Render Phase）：
│   ├─ 协调（Reconciliation）：生成虚拟 DOM，Diff 算法计算变更
│   └─ 调度（Scheduler）：优先级排序和时间切片
│
├─ 提交阶段（Commit Phase）：
│   ├─ 更新 DOM（应用 Diff 结果）
│   └─ 执行生命周期/Effect 钩子
│
└─ 事件系统（SyntheticEvent）：
    ├─ 委托全局事件
    └─ 派发合成事件

### 总结核心创新
响应式设计：状态驱动 UI，单向数据流。
性能优化：虚拟 DOM + Fiber 并发渲染。
开发体验：组件化 + 声明式语法。
扩展性：Hooks 抽象逻辑，Context 状态共享。
React 的底层设计使其在复杂应用和高性能场景中表现卓越，但需要开发者手动优化（如 memo），这是其“显式哲学”的体现。

### 浏览器模块化及React运行逻辑
1、打包工具，会形成引射表，通常是 JS 对象，记录模块id和模块文件.js的位置。
2、浏览器执行到import时
  会去查找引射表，然后去下载或者搜索自己的硬盘，找到文件，然后下载后存入内存（由浏览器缓存机制管理），然后把缓存的资源交给v8；
  模块实例存储在模块作用域（非全局作用域），由 V8 的模块系统管理，也就是v8引擎会在内存中创建一个变量这个变量管理这模块资源。后续用到什么模块，就去这个变量中查询使用。
3、React 的本质：一个通过模块化加载的 JS 库，提供声明式组件模型和高效的 DOM 更新策略。
内存管理：
  模块代码：由 V8的模块系统管理，长期存活。
  运行时对象：由 React 的 Fiber 架构主动维护引用，按需创建/销毁。
V8 的 GC Roots
  │
  ├─ 模块系统（如 Webpack 的模块缓存）
  │    │
  │    └─ React 模块实例（通过 `import` 加载的 `react` 包）
  │         │
  │         ├─ React 核心算法（Diff、调度逻辑）→ 常驻内存（模块闭包）
  │         │
  │         └─ 当前应用的 React 根实例（如 `ReactDOM.createRoot()`）
  │              │
  │              └─ Fiber 树根节点（`current` 或 `workInProgress`）
  │                   │
  │                   ├─ 组件 Fiber 节点 1 → 状态（Hooks）、子节点、兄弟节点
  │                   ├─ 组件 Fiber 节点 2 → ...
  │                   └─ ...
  │                        │
  │                        └─ 虚拟 DOM（JS 对象，挂载到 Fiber 节点的 `memoizedProps`/`stateNode`）
  │
  └─ 其他可达对象（如全局事件监听、未被卸载的组件引用）
总结：
  v8的root变量下管理模块系统
  然后模块系统中管理react实例
  然后react实例有通用的算法调度逻辑、然后同时管理各个createRoot()出的root实例
  然后每个root实例继续管理fiber树
  fiber树中每个节点都管理一个虚拟dom对象。
  diff算法本质就是：当检测到fiber树中数据变化时，会顺着root实例下的fiber树的各个节点进行对比，是否新增删除了fiber节点，以及是否是同一个fiber节点，其中的虚拟dom的内容是否有变化。最后将变化的部分利用浏览器的api进行更新到真实dom。
  Hooks依赖收集原理：React在Fiber节点的memoizedState属性上维护一个Hooks链表，每个Hook对应一个节点；当组件重新渲染时，React 会取出上一次的依赖数组（存储在 Hook 的 memoizedState），对比新旧依赖项（使用 Object.is 进行浅比较）：如果所有依赖项都没变（Object.is(oldDep, newDep) === true），则跳过 Hook 的执行。如果有任何一个依赖项变化，则重新执行 Hook。

### 与Vue的区别
Vue：基于响应式数据劫持（自动依赖跟踪）


## 技术细节实现典型案例

### 如何被点击后下载内容
利用a标签下载
```jsx
function doDownload(url: string, fileName: string) {
  const a = document.createElement('a');
  a.download = fileName;
  a.href = url;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

// 图形下载的主要方法
// 位图（像素）
const downloadCanvasQRCode = () => {
  const canvas = document.getElementById('myqrcode')?.querySelector<HTMLCanvasElement>('canvas');
  if (canvas) {
    const url = canvas.toDataURL();
    doDownload(url, 'QRCode.png');
  }
};
// 矢量图
const downloadSvgQRCode = () => {
  const svg = document.getElementById('myqrcode')?.querySelector<SVGElement>('svg');
  const svgData = new XMLSerializer().serializeToString(svg!);
  const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);

  doDownload(url, 'QRCode.svg');
};
```

## TS

### 类型工具
GetProp<T,K>
声明一个名为 GetProp 的类型别名，它接受两个类型参数 T 和 K（其中 K 受限于 keyof T），其类型定义为 T[K]。
ArrayType[number]
[number]是固定语法，用于提取ArrayType的元素类型
```tsx
import { Select } from 'antd';
import type { GetProp, SelectProps } from 'antd';

// 以下两种都可以生效
type SelectOptionType1 = GetProp<SelectProps, 'options'>[number];
type SelectOptionType2 = GetProp<typeof Select, 'options'>[number];
// 模拟本质
type MyGetProp<T,K extends keyof T>=T[K];

// keyof T 为从T类型中取出所有属性名对于的类型
type SelectPropKeys = keyof SelectProps; // "options" | "mode" | ...

// 单一类型数组
type StringArray = string[];
type StringItem = StringArray[number]; // string

// 多类型数组（联合类型）
type MixedArray = (string | number)[];
type MixedItem = MixedArray[number];   // string | number

// 元组（固定位置类型）
type Tuple = [string, number];
type TupleItem = Tuple[number];        // string | number

// typeof 获取实例类型
const Select = ({ options }: SelectProps) => { /* ... */ };
type SelectType = typeof Select; // (props: SelectProps) => JSX.Element这是一种方法类型
```
#### extends的理解
（1）视角差异
类继承：开发者关注的是类型能力的扩展（子类新增方法/属性）。
泛型约束：开发者关注的是类型范围的缩小（限制泛型参数的取值范围）。
（2）类型理论的一致性
无论类继承还是泛型约束：
A extends B 永远表示「A 的值集合是 B 的子集」。
类继承中子类「更大」是指它的类型描述更复杂（新增成员），但其值的范围更小（只能是更具体的实例）。
==总结==：A类型属于B类型的子类型，不管用在泛型中还是类接口继承。A的类型都要范围更小，更精确，而B的范围更大更模糊能包容更多类型。

## 模拟服务端

### JSON Server
#### 安装与启动
使用0.17.4版本，可以解决跨域问题
```bash
npm install json-server@0.17.4
```
#### 创建数据库文件 db.json
文件位置可以直接放在project下，也就是同package.json同层级；也可在project下创建一个/mock/db.json
内容被服务端访问CRUD后，数据是持久修改的，直接手动修改 db.json 文件会导致服务自动重启并生效
```json
{
  "posts": [
    { "id": 1, "title": "JSON Server 入门", "author": "张三" },
    { "id": 2, "title": "RESTful API 设计", "author": "李四" }
  ],
  "comments": [
    { "id": 1, "body": "好文章", "postId": 1 },
    { "id": 2, "body": "好文章好", "postId": 2 }
  ]
}
```
URL 由 db.json 的键名决定
id字段为必须值，是URL访问时具体数据的关键，且会自增，所以POST时，可以数据对象中缺少id属性，只写其他属性
也可自定义id，但是需保证不重复，可通过 GET 请求获取所有数据后计算
```tsx
axios.get('http://localhost:3000/posts')
  .then(res => {
    const maxId = Math.max(...res.data.map(item => item.id));
    console.log(`下一个可用 id: ${maxId + 1}`);
  });
```
#### 启动服务
如果db.json不直接暴露在project下，需要加db.json的文件夹前缀例如--watch mock/db.json
```bash
json-server --watch db.json --port 3000
```
为了解决跨域问题，需要配置server.js
```js
import jsonServer from 'json-server';

const server = jsonServer.create();
const router = jsonServer.router('db.json');
const middlewares = jsonServer.defaults();

// 自定义 CORS 中间件
server.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', 'http://localhost:5173'); // 改为你的前端地址
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type');
  res.header('Access-Control-Allow-Credentials', 'true'); // 允许携带凭证
  next();
});

// 默认中间件（如日志、静态文件等）
server.use(middlewares);

// 路由
server.use(router);

// 启动服务器
server.listen(3000, () => {
  console.log('JSON Server is running at http://localhost:3000');
});
```
然后直接node server.js启动即可，无需单独启动json-server命令
注释，可以根据需求，在server.js中增加其他中间件，包括分页功能，文件上传功能，文件的命名规则等，具体见server.js
```bash
node server.js
```
#### 访问服务
| 请求类型 | URL               | 作用               |
| -------- | ----------------- | ------------------ |
| GET      | /posts            | 获取所有文章       |
| GET      | /posts/1          | 获取 ID=1 的文章   |
| POST     | /posts            | 新增文章           |
| PUT      | /posts/1          | 替换 ID=1 的文章   |
| PATCH    | /posts/1          | 部分更新文章       |
| DELETE   | /posts/1          | 删除文章           |
| GET      | /posts?title=JSON | 过滤标题包含"JSON" |

注释：
举例代码：URL中posts/1意义为id=1的数据，
```tsx
axios.get('http://localhost:3000/posts?author=张三')
  .then(res => {
    console.log(res.data); 
    // 输出示例：
    // [{ id: 1, title: "JSON Server 入门", author: "张三" }]
  })
  .catch(err => console.error(err));
  // 这种?形式的一般用于需要除了id之外的过滤条件时使用。
axios.get('http://localhost:3000/posts', {
  params: { author: '张三' }  // 注意是 `params` 属性
})
```

## 现代项目设计架构类型

### 前后端分离的方案对比（CSR\SSR\SSG）
#### 基础概念
CSR：也就是客户端渲染，用js异步接收各种数据，然后渲染
SSR：把原本需要在客户端（浏览器）完成的首次渲染工作，挪到服务器端提前完成。就是把 CSR 中“客户端JS请求数据->渲染”这一步，搬到了服务器端执行，然后把结果（HTML）直接给了客户端。
详细过程：
  浏览器请求服务器。
  服务器收到请求，不是返回一个空壳，而是：
    a. 在内存中启动一个 JS 环境（Node.js）。
    b. 执行你的前端框架代码（React/Vue组件）。
    c. 当组件执行到 useEffect、onMounted 或异步数据 fetching 时，服务器会等待这些API请求完成。
    d. 服务器将已经填充了真实数据的组件渲染成最终的 HTML 字符串。
  服务器将这个“带数据的、完整的”HTML 发送给浏览器。
  浏览器立即就能展示出完整内容的页面（首屏速度极快，利于SEO）。
  同时，打包好的 JS（React/Vue本身、组件代码）也会被下载到浏览器。
  JS 执行后，会“接管”（Hydrate）已有的静态HTML，使其重新变成一个可交互的SPA。
SSG：SSG是CSR和SSR的中间态，在构建时就加工一部分长时间不会变化的数据到html中生成一个半成品网页，然后把这个半成品的html及相关的css和js一起给到客户端，然后客户端能先展示重点内容，且同时异步请求得到剩余的需要经常更新的数据，最后完成全部内容的展示。（SSG 生成的是“静态骨架”+“静态内容”，而将“动态内容”的坑位留出来，由客户端JS来填充）

对比
方面|CSR (Client-Side Rendering)|SSR (Server-Side Rendering)|SSG (Static Site Generation)
核心过程|客户端JS异步获取数据并渲染|服务器每次请求时实时获取数据并渲染HTML|服务器构建时获取数据并预渲染HTML
SEO|差。搜索引擎可能无法等待JS执行。|优。直接返回完整HTML。|优。直接返回完整HTML。
首屏加载|慢。需等待JS下载、执行、数据 fetching、渲染|	快。直接渲染HTML，但仍有“可交互时间延迟”|	极快。CDN直接返回现成HTML。
服务器压力|小。服务器只提供静态文件和API。|大。每次页面请求都需要服务器CPU渲染。|极小。CDN承担全部流量。
数据实时性|高。每次访问都请求最新数据。|高。每次访问都请求最新数据。|需配置。默认是构建时的数据，需通过revalidate或客户端fetch更新。
适用场景|后台管理系统、强交互WebApp、登录后页面。|高实时性要求的C端网站（如新闻、社交）。|博客、文档、电商产品页、公司官网、营销页。
技术栈|React, Vue, Angular + Vite/Webpack|Next.js (React), Nuxt.js (Vue), SvelteKit|Next.js, Nuxt.js, Gatsby, VuePress, Hugo
部署|静态服务器 / CDN|需要Node.js服务器（或Serverless边缘函数）|静态服务器 / CDN
开发复杂度|简单|较高（需关心服务器状态、内存泄漏等）|中等（需区分构建时和客户端逻辑）

总结与选择建议：
选 CSR：如果你做的是不需要SEO的应用型网站（如管理系统、SaaS平台后台）。
选 SSR：如果你做的是内容驱动且极度追求最新实时性的网站（如微博、头条）。
选 SSG：如果你做的是内容驱动但内容变化频率不高的网站（90%的网站都属于此类）。它是性能、成本和SEO的最佳平衡点。

现代框架的趋势（如Next.js, Nuxt.js）是“混合渲染”：允许你为网站的不同页面选择不同的渲染模式。例如，主页和产品页用SSG，个人中心页用CSR，实时排行榜用SSR。这提供了极大的灵活性。
#### SSG和SSR如何实现的
实现 SSG 和 SSR 确实需要不同的框架和构建工具，项目的编写方式和结构也会有显著区别。
传统的 Vite/Webpack CSR 项目：
入口：一个 index.html 和一个 main.js。
构建命令：vite build。
输出：一套静态资源（HTML, JS, CSS）。index.html 里的 <div id="app"></div> 是空的。
运行：需要一台始终运行的 Node.js 服务器，或者直接扔到CDN上。

SSG/SSR 项目（以 Next.js 为例）：
入口： pages 目录下的页面组件（如 pages/about.jsx）。
核心概念：数据获取函数。
SSG：使用 getStaticProps()。这个函数在构建时运行，它的返回值会作为组件的 props，用于渲染出静态HTML。
SSR：使用 getServerSideProps()。这个函数在每次用户请求时在服务器端运行，它的返回值用于实时渲染HTML。
一个简单的 SSG 示例 (Next.js)：
```jsx
// pages/products/[id].jsx
// 1. 这个函数在构建时运行，告诉Next.js需要预渲染哪些产品页
export async function getStaticPaths() {
  // 从CMS或数据库获取所有产品ID
  const products = await fetch('https://.../products').then(r => r.json());
  const paths = products.map((product) => ({
    params: { id: product.id.toString() }, // 生成像 /products/1, /products/2 这样的路径
  }));

  return { paths, fallback: false };
}

// 2. 这个函数在构建时为每个产品页运行，获取产品数据
export async function getStaticProps({ params }) {
  const product = await fetch(`https://.../products/${params.id}`).then(r => r.json());
  
  // 返回的数据会作为 props 传递给 Page 组件
  return { 
    props: { product },
    revalidate: 60 // (可选) 增量静态再生：60秒后如果有新请求，会在后台重新生成页面
  };
}

// 3. 页面组件：接收 getStaticProps 返回的数据，用于渲染
export default function ProductPage({ product }) { // product 来自 getStaticProps
  return (
    <div>
      <h1>{product.name}</h1> {/* 这部分是构建时就生成好的静态内容 */}
      <p>{product.description}</p>

      {/* 价格库存可能是动态的，需要客户端再获取 */}
      <DynamicPrice productId={product.id} />
    </div>
  );
}

// 4. 这个组件会在客户端运行，获取实时数据
function DynamicPrice({ productId }) {
  const [price, setPrice] = useState(null);
  useEffect(() => {
    fetch(`/api/price/${productId}`).then(...).then(setPrice); // 客户端获取动态数据
  }, [productId]);

  return <div>Current Price: {price}</div>;
}
```
构建命令：next build && next export（纯静态SSG） 或 next build（用于混合模式或SSR）。
输出：
SSG：一套完整的静态HTML文件（如 products/1.html, products/2.html），可直接部署到CDN。
SSR：需要一台始终运行的 Node.js 服务器来执行 getServerSideProps。


### SPA项目设计架构
#### 运行的逻辑
1、浏览器对dashboar第一次请求，根据同源策略，会自动检查本地是否有domain=example.com的cookie，有的话就带上（这个很重要，可以让已经有本地token的刷新，保持页面，不需要重新每次都登陆，不过这不代表只登陆过一次，就一直可以展示权限内容了，每次刷新页面，页面中的js代码仍然会给服务器发送请求验证当前的token有效性）。
2、服务端收到请求后，直接统一先返回一个index.html（包含script标签引用main.bundle.js）main.bundle.js，这个文件是整个前端源码打包压缩的，也就是对应的源码是index.html\main.tsx\app.tsx\其他所有的src下被连接到app上的代码。
3、浏览器收到上述的全量代码后开始执行，由于代码执行的顺序，从上到下，从外层组件到内存组件，所以当执行到main中的内容时，会先于app组件执行AuthProvider组件中的内容，而AuthProvider中的js代码会利用axios给服务发送一次验证用户token的请求，得到服务器的res后，仍然在浏览器内通过AuthProvider中js代码生成验证结果如isAuthenticated、role等信息。
4、然后浏览器执行app组件中的代码，会根据isAuthenticated、role等信息将原始app全量代码加工为对应权限路由的代码（其实全部页面的代码都在浏览器，只是浏览器根据res的结果及对应的isAuthenticated、role等state加工生成能显示的页面路由部分），然后通过Navigate标签自动修改location，控制页面显示对应路由的内容。
5、如果以上理解都对的话，那么如果我已经验证成功了，且在dashboard了，刷新页面，又会重复执行上述的所有步骤是么？唯一的区别是，可能第二部服务器会告诉浏览器可以使用缓存的main.bundle.js。而浏览器使用后，继续重复上述步骤从index、到main、到AuthProvider、到重新发送请求验证token及生成对应的isAuthenticated、role等信息，及后续的页面根据isAuthenticated、role等信息加工为对应的展示路由。

#### 现代SPA架构的核心思想
代码全量下发 + 运行时动态校验
安全不依赖代码保密，而靠API严格防护
用户体验优先，通过客户端路由实现无缝跳转

#### 同源策略
##### cookie携带
所有同源请求都会自动携带匹配的Cookie。
例如访问https://example.com/dashboard，会携带domain=example.com的cookie。
如果不是单服务器的跨域情况，可以如下强制携带cookie
```jsx
axios.get('/api/validate-token', { withCredentials: true })
```

### 微前端
#### 运行逻辑
1、浏览器发送请求。假设为第一次，所以没有携带cookie，且location还访问了需要权限的/admin/setting。
2、服务器收到请求后，先返回宏应用的整个资源文件。
3、浏览器收到资源文件解析，运行宏应用代码：（1）先运行至身份验证部分，会发送一个异步请求，尝试携带cookie，给服务器，服务器收到该请求后，返回res。（2）浏览器解读res，因为是第一次请求没有cookie，所以没有验证通过，所以宏应用中的代码将展示login登录页。
4、浏览器输入登录信息后继续发送请求，服务器收到请求后，验证通过，返回res，且res会给浏览器setcookie。
5、浏览器收到res后，发现已通过验证，则navigate至默认主页。重新向服务器发出请求，服务器返回res表示可以使用缓存的宏应用代码。浏览器重新解析宏应用代码，再次运行至身份验证的异步请求代码，这次res为通过。浏览器将宏应用的代码解析为默认主页展示。
6、用户点击sider更改了location。
  （1）更改了location会触发宏应用注册的监听器history.listen中的回调函数。该回调函数通过到微应用注册表中检测与location.pathname队友的微应用，得到该对象matchedApp。
  （2）继续触发loadMicroApp函数，将matchedApp.entry也就是该微应用位于服务器的文件全路径传入。
  （3）创建一个script元素，将该元素的src赋值为matchedApp的服务器上的文件全路径。同时设置script加载完成时的回调函数onload。最后将该script添加至DOM中触发请求。
  （4）浏览器向服务器发送该matchedApp的下载请求，同时这个请求由于同源策略会携带cookie。
  （5）服务器收到请求后，验证cookie通过，返回该微应用的js资源。
  （6）浏览器在收到完整的微应用的js资源后：a、执行微应用代码，注册window.MicroApp1。b、执行宏应用的onload回调。c、调用微应用暴露的挂载方法window[当前微应用名].mount('#micro-app-container');将微应用挂载至宏应用预留的div中，具体为ReactDOM.render(React.createElement(App), document.getElementById(containerId));
7、然后浏览器执行该微应用js代码，继续请求相关的css及数据资源。最后浏览器收到资源后完成了整个页面的展示。
8、如果请求时携带了cookie，则运行的流程与上述是一样的，只是宏应用中有一部分代码
```tsx
// 宏应用启动时
const initialPath = window.location.pathname;
const initialApp = matchMicroApp(initialPath); // 路由匹配函数

if (initialApp) {
  loadMicroApp(initialApp.entry);
}
```
这部分代码会手动调用一次loadMicroApp去请求微应用然后挂载。
#### UMD挂载机制
1、webpack打包工具将微应用源码中的bootstrap.js中暴露的export const mount = () => { /*...*/ }，加工输出为
```jsx
// dist/micro-app1.js 的内容结构
(function() {
  // 1、微应用的原始组件内容
  function App() {
    return React.createElement('div', { 
      className: 'app' 
    }, '微应用内容');
  };

  // 2. 微应用注册信息
  window.MicroApp1 = {
    const root;
    mount: function(containerId) {
      root = Reactdom.createRoot(document.getElementById(containerId))
      root.render(<App/>)
    },
    unmount:function(){root.unmount();root=null}
  };
})();
```
传统SPA：
  组件完全由React控制，卸载时自动清理
微前端：
  window.MicroApp1 是微应用的注册点（永久存在直到页面刷新）
  root实例是运行时对象（挂载时创建，卸载时销毁）
  与SPA的本质区别：微应用的Root是"寄生"在宏应用中的独立宇宙，需要手动管理生命周期

必须给注册信息设置unmount，因为：
第一次产生的root =  ReactDOM.createRoot(container) ，这个root容器持有了App1的fiber树。
第二次产生的root =  ReactDOM.createRoot(container) ，这个root容器持有了App2的fiber树。
这个root变量名又不是全局的，是宏应用监听history，调用loadMicroApp函数，产生的script下载微应用代码，微应用代码中执行得到了root，那么不同的微应用代码就是隔离开的作用域，里面的root变量也是隔离开的。
就算reactDOM警告同一个节点创建两个root，仍可新创建的reactroot，且被第二个script中的root变量指向，且又调用了一次render，导致新的reactroot中挂载的fiber树为app2。（container._reactRootContainer=newRoot）
而第一个script中的root变量，仍然指向第一次创建的reactroot，该reactroot仍然挂载app1的fiber树。
而react的特性，针对同一个节点创建的reactroot，只渲染出最后一个，所以最后页面显示了app2的fiber树。
至于第一个reactroot为什么没有销毁，是因为root与fiber树双向指针，无法自动销毁，必须手动调用unmount才可以。

### ICESTARK
#### 微应用内部文件协作方式
1、核心在于index.html主入口，然后app.tsx挂载方法，routes.ts提供内容。这三个文件相辅相成的。
2、至于routes.ts中的具体路由表，都可以按照需求随意修改。甚至basiclayout也是可以随意更改的，只要在routes.ts中明确即可。
3、app.tsx的作用就是：
  （1）appConfig可以是默认的，那routes文件的位置名字（src/routes.ts）、index.html中挂载节点名id="ice-container"都必须维持原始的。
  （2）runApp方法，就是将routes中的路由整合好后，挂载至index.html的<div id="ice-container"></div>中。
  （3）当作为微应用时，挂载方式会变化，就是把<div id="ice-container"></div>节点作为宏应用提供的rootdiv（mount 方法的形参container）的子元素嵌套挂载。
  ```tsx
  // ice.js 内部逻辑
  if (isInIcestark()) {
    // 改用 icestark 提供的挂载方式
    export const mount = ({ container }) => {
      container.innerHTML = '<div id="ice-container"></div>';
      runApp();
    };
  }
  ```
以及：源码里，从入口index.html看不到哪里调用了app.tsx中的runapp方法。是因为需要经过打包软件按照固定配置去生成build后的index和对应的js、css文件，然后这些文件中有js调用runapp方法。
生成如下结构
```tsx
<div id="ice-container">
  <Routes>
    <Route path="/" element={<BasicLayout />}>
      <Route index element={<Home />} />
      <Route path="detail" element={<Detail />} />
      <Route path="list" element={<List />} />
    </Route>
  </Routes>
</div>
```
#### 主应用内部文件协作方式及运行逻辑
1、同微应用一样，核心文件就是三个：index.html主入口，app.tsx，routes.ts。
2、routes.ts用于提供主应用路由，用当pathname对应routes的内容时，根布局组件{children}表达为<Outlet>的内容。
3、app.tsx，用于配置主应用：
（1）appConfig.app.rootId控制根id，及.addProvider提供ConfigProvider。
（2）icestark.Layout提供主应用的根组件（根组件的props中，children很重要，用于传递根据pathname动态渲染为现有routes中的路由，还是<div id="micro-app-container"></div>）。
（3）icestark.getApps用于设置微应用的具体信息，用于当pathname对应getApps微应用的内容时，根布局组件{children}表达为<div id="micro-app-container"></div>的内容。

```tsx
// 主应用形成的结构
<div id="icestark-container">
  <Routes>
    <Route path="/login" element={<Login />}/>
    <Route path="/" element={<BasicLayout />}>
      {pathname匹配主应用路由 ? (
        <Routes>
          <Route path="/home" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      ) : (
        <div id="micro-app-container" data-entry="微应用URL"></div>
      )}
    </Route>
  </Routes>
</div>
```

## 组件库

### ANTD库的设计思想
#### 组件形式
核心就两个：
（1）定义能接受的用户自定义的props供修改。
（2）根据props来返回已经初步集成单元模块的功能。
#### 主题样式
（1）已有的主题，保存在less中，包含各种属性变量，固定的类名及样式。（2）组件通过样式名去less文件中找到对应的样式值，然后展示出来。（3）主题的less，可以通过
```jsx
<ConfigProvider theme={{ token: { colorPrimary: '#ff4d4f' } }}>
  <App />
</ConfigProvider>
```
的形式，去修改，注入的token属性
#### 主题修改的的底层原理
默认阶段
编译后的 CSS：
```css
:root {
  --ant-primary-color: #1890ff; /* 默认值 */
}
.ant-btn-primary {
  background: var(--ant-primary-color);
}
```
ConfigProvider动态注入阶段
动态插入 <style> 标签：
```css
.ant-theme-vars {
  --ant-primary-color: #ff4d4f; /* 覆盖值 */
}
```
为 ConfigProvider 的容器添加类名：
```html
<div class="ant-theme-vars">
  <!-- App 的所有子组件 -->
</div>
```
变量解析顺序：
浏览器遇到 .ant-btn-primary 时，发现 background: var(--ant-primary-color)。
从当前元素向上查找 --ant-primary-color 的定义：优先找到 .ant-theme-vars 中的 #ff4d4f（就近原则）。如果找不到，则回退到 :root 的 #1890ff。
#### 总结
定义变量：:root 下声明默认值。
引用变量：组件样式通过 var() 使用变量。
动态覆盖：通过 .ant-theme-vars 插入新值，作用域限定在子树内。

### ANTD具体组件
#### Form组件的验证规则及时序
核心是 form.validateFields()的执行，也就是form的实例在什么时候被固化选中的。调度器遇到async函数会整体挂起， form.validateFields()这个段代码的执行暂停，让出执行权，放入微任务，等待主线程将其他的代码（如antd的form的跟新）执行完毕后，再继续执行 form.validateFields()，所以这时的form就是新的已更新的实例。
代码如下，以下两种看是逻辑完全一致，但是两个form实例完全不一样，第一种的form是antdform的数据还没更新时的，也就是不包含本次输入的最新数据，所以当validator中如果使用到了form.fetfiledvlue的话，会用旧的form验证，导致验证出错。
```jsx
 const handleRamChange = (index: number, value: string) => {
    form.validateFields(["salesAttributes", "ram", index]).then(() => {
      setData((prev: any) => ({
        ...prev,
        salesAttributes: {
          ...prev.salesAttributes,
          ram: prev.salesAttributes.ram.map((item: any, i: number) =>
            i === index ? value : item
          ),
        },
      }));
    });
  };
  const handleRamChange = async (index: number, value: string) => {
    console.log("验证前data:", data);
    try {
      await form.validateFields([["salesAttributes", "ram", index]]);
      setData((prev: any) => ({
        ...prev,
        salesAttributes: {
          ...prev.salesAttributes,
          ram: prev.salesAttributes.ram.map((item: any, i: number) =>
            i === index ? value : item
          ),
        },
      }));
    } catch (err) {
      console.log("验证失败时data:", data); // 检查此时data状态
      console.error("验证错误:", err);
    }
  };
```

### Animate.css
一个动画库，只需要给元素添加对应的类名即可有动画效果，具体见官网。

## 工程化

### 工程化含义
1. 什么是前端工程化？
是一种标准化的思想，将代码开发到部署上线的各个阶段划分，通过工具进行管理，实现标准化、便利化、高质量、维护性好的目的。

2. 从开发到部署上线的全过程
阶段	核心任务	工具与技术举例
1）. 开发 (Development)	编写代码、本地调试、启动开发服务器	编辑器: VSCode, WebStorm
开发服务器: Vite, Webpack Dev Server
2）. 依赖管理与构建 (Dependency & Build)	安装第三方库、将源码转换为浏览器可运行的代码	包管理器: npm, yarn, pnpm
构建工具: Webpack, Vite, Rollup, esbuild
语言: TypeScript, Sass/Less, JSX/Vue SFC
3）. 代码质量保障 (Quality Assurance)	保证代码风格统一、发现潜在错误、运行测试	代码检查: ESLint
风格格式化: Prettier
单元测试: Jest, Vitest, Mocha
端到端测试: Cypress, Playwright
4）. 持续集成/部署 (CI/CD)	自动化测试、检查、构建并部署到服务器	Git 平台: GitHub, GitLab, Gitee
CI/CD 工具: GitHub Actions, GitLab CI, Jenkins
部署平台: Vercel, Netlify, 自有服务器(Nginx), Docker, K8s

3. 业界著名的工程化辅助工具
脚手架 (Scaffolding)：Create React App (CRA), Vue CLI, Vite, Next.js, Nuxt.js, Umi (蚂蚁金服)。作用：快速生成一个配置好基础工具和目录结构的项目。
包管理器 (Package Manager)：npm, yarn, pnpm (目前趋势是pnpm，速度快、磁盘空间利用高效)。
构建工具 (Bundler)：Webpack (功能强大、生态最全但配置复杂)，Vite (基于ESM，开发环境极速，新一代主流)，Rollup (常用于库的打包，输出更简洁)，esbuild (Go编写，速度极快，常用于底层工具)。
编译器/转译器 (Compiler/Transpiler)：Babel (将ES6+代码转译为兼容性更好的ES5代码)，TypeScript Compiler (tsc) (将TS编译为JS)。
代码检查与格式化 (Linting & Formatting)：ESLint (检查JavaScript/TS代码质量和风格)，Prettier (代码格式化)，Stylelint (检查CSS代码)。
测试 (Testing)：Jest (全方位的测试框架)，Vitest (基于Vite，速度更快)，Cypress, Playwright (端到端E2E测试)。
CI/CD：GitHub Actions, GitLab CI, Jenkins。

4. 向后设计（可维护性与可扩展性）
技术选型：选择社区活跃、有长期维护、能满足未来业务发展的技术栈（如Vue 3 + Vite + Pinia + TypeScript）。
目录结构可扩展：目录结构不能太死板。例如，当 components 下的组件过多时，可以考虑按功能再进行文件夹分组。
配置化：将可能变化的逻辑（如菜单、路由、功能开关）抽离成配置文件，未来修改只需改配置，而不用动代码。
构建优化预留：在构建配置中提前考虑代码分割、懒加载、外部化等优化点，为应用规模变大做准备。
错误监控与日志：预留接口，方便后期接入Sentry等前端监控系统。
组件抽象：设计组件时思考其通用性，采用高内聚低耦合的原则，使其更容易被复用和扩展。

### 打包构建
1. 打包压缩在前端工作中的重要度占比
打包压缩是前端工程化的基石之一。 虽然在实际开发中，由于脚手架（如 Create React App, Vite）的成熟，开发者直接手动配置打包工具的时间占比可能不高（可能在10%-30%，取决于项目规模和是否需要定制），但理解其原理是100%必要的。
它的重要性体现在以下几个方面：
开发效率： 提供热更新（HMR）、语法转换（如JSX、TS）、代码分割等功能，让开发者能用最舒服的方式写代码。
性能优化： 这是最核心的价值。通过压缩（Minification）、摇树（Tree-shaking）、代码分割（Code Splitting）、资源优化（图片转base64、压缩）等手段，极大减少用户浏览器需要下载的资源体积和请求数量，直接提升网站加载速度和用户体验。
兼容性处理： 通过Babel等工具将现代JavaScript、CSS语法转换为兼容旧浏览器的代码。
资源管理： 将项目中散落的模块（几十上百个.js、.css、图片、字体文件）有序地组织、合并成少数几个优化后的文件。
结论： 你可能不天天写webpack配置，但你必须懂它。否则遇到性能瓶颈、需要自定义优化、或者调试构建错误时，你会束手无策。

2. Webpack vs Vite
这是一个“老牌冠军”与“新锐巨星”的对比。
特性	Webpack	Vite
构建理念	Bundle（打包）。无论项目大小，每次启动开发服务器都需要先打包所有代码，生成bundle。	ESM（原生ES模块）。启动时直接启动服务器，按需编译和提供源文件。开发环境无需打包。
开发服务器启动速度	慢。项目越大，依赖越多，启动和热更新速度越慢。	极快。几乎秒开，热更新速度也非常快。
生产构建	非常成熟和强大。拥有极其丰富的插件生态和优化手段，能处理非常复杂的场景。	同样成熟。底层使用Rollup（专注于ESM的打包器），构建输出非常高效。对于大多数项目足够优秀。
配置复杂度	高。“配置地狱”闻名于世，学习曲线陡峭。	低。开箱即用，预设了大量优化。需要配置时，也更清晰简单。
适用项目	极其广泛。从传统多页应用（MPA）到现代单页应用（SPA），超大型、复杂项目。	现代Web项目。SPA、SSR项目体验极佳。对传统非ESM的旧库支持可能稍弱。
使用频率	仍然极高。大量存量项目和大型项目在使用，生态无可匹敌。	飞速上升。新项目的首选趋势，尤其是React、Vue等现代框架项目。
总结与选择：
Vite：绝大多数新项目（特别是SPA）的首选。它的开发体验是革命性的，速度快到回不去。npm create vite 是现在最流行的快速创建项目的方式。
Webpack：当你需要处理非常特殊的构建需求、或者维护一个老旧庞大的项目时。它的可定制性和生态成熟度依然是顶级的。

3. “傻瓜式”一键build是实际常用的吗？如何自己配置？
是的，极其常用！
对于绝大多数标准的单页应用（SPA），比如你用 npm create vite 创建的React项目，npm run build 一键构建就是标准且推荐的做法。Vite和CRA（Create React App）这些脚手架背后的团队已经为你预置了经过千锤百炼的优化配置，涵盖了代码分割、压缩、资源处理等最佳实践。你不需要重新发明轮子。
什么时候需要自己配置？
需要自定义行为时：比如，你想改变打包输出的文件结构、设置特定的公共路径（publicPath）、集成新的预处理语言（如Sass）。
需要优化或使用高级功能时：比如，你想使用Webpack Bundle Analyzer分析包体积、配置更复杂的代码分割策略、使用CDN引入某些库（externals）。
项目结构特殊时：比如，你正在开发一个多页应用（MPA），就像你提供的那个webpack配置例子一样，每个页面都有自己的入口HTML和JS。
如何自己配置？
以Vite为例，它的配置文件是 vite.config.js。
如果你想修改输出目录，可以在配置里设置 build: { outDir: 'my-dist' }。
如果你想使用SVGR插件将SVG转换为React组件，你需要安装并配置 vite-plugin-svgr。
```js
// vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import svgr from 'vite-plugin-svgr' // 一个自定义插件

export default defineConfig({
  plugins: [react(), svgr()], // 配置插件
  build: {
    outDir: 'build', // 自定义输出目录名
  },
  // 其他配置...
})
```
核心是：先用好“傻瓜式”，遇到瓶颈或特殊需求时，再通过学习去修改配置。

4. Webpack配置与Vite脚手架配置对应的使用场景
是的，你提供的这个webpack配置是一个非常经典和实际的多页应用（MPA）配置案例，现在依然会这样用。
它与Vite脚手架（主要面向SPA）的主要区别在于项目类型：
项目结构不同：
你的Webpack案例： 是 MPA (Multi-Page Application)。它有多个入口（login, content, publish）和多个HTML模板。最终会生成/login/index.html、/content/index.html等多个独立的页面。这是比较传统的Web开发模式。
Vite React脚手架： 是 SPA (Single-Page Application)。它通常只有一个入口（如 src/main.jsx）和一个HTML模板（index.html）。整个应用是一个完整的JavaScript应用，通过前端路由（如React Router）来切换页面视图。
配置复杂度不同：
MPA的Webpack配置必然更复杂，因为需要为每个页面单独配置 HtmlWebpackPlugin，并指定对应的 chunks。还需要考虑如何避免不同页面间的代码重复（所以用了 splitChunks）。
SPA的Vite配置默认非常简单，因为它只需要处理一个入口。
开发体验不同：
用这个Webpack配置开发，每次启动依然需要一段时间进行打包。
用Vite开发一个SPA，启动速度极快。
结论： 两种配置都是“实际开发中在用”的，但它们服务于不同类型的项目。没有谁更好，只有谁更合适。如果你要做的是一个拥有多个独立页面的网站（比如企业官网、电商首页、登录页），你的Webpack配置就是标准做法。如果你做的是一个复杂的、交互密集的Web应用（比如后台管理系统、在线文档、社交平台），那么SPA模式（Vite）更合适。

5. 总结与补充
你对打包的理解已经上路了，我来帮你梳理和补充一些核心概念：
打包（Building/Bundling）： 核心目的是将多个文件合并成少数几个文件。浏览器并发请求数量有限，且每个文件都有头尾开销。合并文件可以减少请求数，提升加载效率。
转换（Transforming）： 利用Loader（Webpack）或Plugin（Vite）对源代码进行预处理。比如：
babel-loader 把 ES6+/JSX 转成 ES5。
sass-loader 把 SCSS 转成 CSS。
ts-loader 把 TypeScript 转成 JavaScript。
优化（Optimizing）： 这是构建流程的精华。
压缩（Minification）： 移除代码中所有不必要的字符（空格、注释、缩短变量名），而不改变其功能。对应插件：TerserPlugin（JS）、CssMinimizerPlugin（CSS）。
摇树（Tree-shaking）： 移除JavaScript上下文中未被引用的代码（dead code）。它依赖于ES Module的静态分析特性。
代码分割（Code Splitting）： 将代码拆分成多个chunk（块），可以按需加载或并行加载。比如：
将第三方库（node_modules）拆分成一个单独的 vendor chunk，因为它们不常变更，可以利用浏览器缓存。
在SPA中，为不同的路由组件生成单独的chunk，实现路由懒加载。
资源优化（Asset Optimization）： 压缩图片、将小图片转为Data URL。
给你的建议：
深入理解Vite： 你现在主要用Vite，就去好好读一读Vite官方文档，了解它的配置项和插件生态。尝试给它加个插件，或者改个配置，理解其工作流程。
不要害怕Webpack： 你提供的那个配置是很好的学习材料。尝试自己从头配置一个简单的Webpack，从处理JS和CSS开始，慢慢加上图片、插件，你会对整个流程有深刻的认识。
关注输出： 每次打包后，不要只是运行了就完事。打开 dist 目录，看看生成了什么文件，它们的结构是怎样的。用 npm run build -- --mode=development 生成未压缩的版本，看看代码被处理成了什么样子。

### 单元测试
针对create vite react+ts 类型的项目的单元测试的具体步骤：
1. 安装 Jest 相关的依赖
```bash
# jest: 测试框架本体。
# @types/jest: 为 Jest 提供 TypeScript 类型定义（即使你写 JS 也能获得更好的提示）。
# babel-jest: 一个 Jest 的“转换器”，它在运行测试前，会用 Babel 先将你的 ESM 代码转成 CommonJS 代码。
# @babel/core & @babel/preset-env: Babel 的核心和预设配置，babel-jest 需要它们来工作。
npm install --save-dev jest @types/jest
npm install --save-dev babel-jest @babel/core @babel/preset-env
# 安装处理 React 和 TypeScript 所需的 Babel 预设
npm install --save-dev @babel/preset-react @babel/preset-typescript

```
2. 创建 Babel 配置文件
在项目根目录下创建babel.config.js文件
```js
// babel.config.js
export default {
  presets: [
    ['@babel/preset-env', { targets: { node: 'current' } }],
    ['@babel/preset-react', { runtime: 'automatic' }], // 新增：用于处理 JSX
    '@babel/preset-typescript', // 新增：用于处理 TypeScript
  ],
};
```
3. 配置 npm 脚本scripts命令
打开 package.json 文件，找到 "scripts" 部分，添加一条测试命令：
```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "jest" // <-- 添加这一行
  }
}
```
4. 根据需要测试文件增加同名测试单元文件xxx.test.ts
例如
```ts
import { add } from "./mathAdd";

// test() 函数定义一个测试用例
// 'adds 1 + 2 to equal 3' 是测试描述
// () => {} 是包含测试逻辑的函数
test('adds 1 + 2 to equal 3', () => {
  // 1. Arrange (准备)：准备测试数据
  const a = 1;
  const b = 2;
  const expected = 3;

  // 2. Act (执行)：调用被测函数
  const result = add(a, b);

  // 3. Assert (断言)：验证结果
  expect(result).toBe(expected);
});

// 你可以添加更多测试用例
test('adds negative numbers correctly', () => {
  expect(add(-1, -2)).toBe(-3);
  expect(add(5, -3)).toBe(2);
});
```

### Eslint及代码检查
1. ESLint 是什么？有什么用？
ESLint 是一个用于识别和报告 JavaScript/TypeScript 代码中模式的静态代码分析工具。通俗讲，它是一个代码检查工具。
2. 常用的个性化配置
ESLint 的配置非常灵活，通常在项目根目录的 .eslintrc.js 或 .eslintrc.json 文件中进行设置。
```js
// .eslintrc.js
module.exports = {
  // 1. 指定代码的运行环境
  env: {
    browser: true, // 可以使用 window, document 等全局变量
    es2021: true,  // 支持 ES2021 的语法（如 Promise.any, Logical Assignment）
    node: true     // 可以使用 require, module 等 Node.js 全局变量
  },

  // 2. 扩展共享配置（这是最重要的部分！）
  extends: [
    'eslint:recommended', // ESLint 官方推荐规则
    'plugin:react/recommended', // React 插件推荐规则
    'plugin:@typescript-eslint/recommended' // TypeScript 插件推荐规则
  ],

  // 3. 指定解析器（用于解析新语法或非标准语法）
  parser: '@typescript-eslint/parser', // 用于解析 TypeScript

  // 4. 插件（提供了额外的规则集）
  plugins: [
    'react',
    '@typescript-eslint'
  ],

  // 5. 自定义规则（覆盖 extends 中的规则，优先级最高）
  rules: {
    // 错误级别：0-off, 1-warn, 2-error
    'no-console': 'warn', // 允许 console，但使用会警告
    'quotes': ['error', 'single'], // 强制使用单引号，否则报错
    'semi': ['error', 'always'], // 强制语句末尾分号，否则报错
    'indent': ['error', 2], // 强制2个空格的缩进
    'react/prop-types': 'off' // 关闭 React 的 prop-types 检查（在TypeScript项目中常用）
  }
};
```
3. Airbnb 是什么 ESLint 规则？
Airbnb ESLint 配置 是 Airbnb 公司开源的一套极其流行和严格的 JavaScript/React 代码风格指南。
它是什么？ 它是一个共享的配置包（eslint-config-airbnb 或 eslint-config-airbnb-base），你可以直接通过 extends 来使用它，而无需自己一条条地定义数百条规则。
它有多严格？ 它被认为是业界最严格的规则集之一，涵盖了代码风格、React 最佳实践、性能优化建议等方方面面。
如何使用？
安装：npx install-peerdeps --dev eslint-config-airbnb (或使用 airbnb-base 不含 React 版本)
配置：在 .eslintrc.js 中 extends: ['airbnb']。
注意：直接在新项目中使用 Airbnb 规则可能会让你“寸步难行”，因为它会报大量错误。通常建议逐步采用，或者选择性地覆盖其中一些过于严格的规则。
4. 编程规范有哪些需要注意？
ESLint 强制的规范主要分为以下几类，这些都是需要注意的：
  格式风格 (Formatting):
    缩进：统一使用空格还是 Tab？用几个？
    引号：单引号 ' vs. 双引号 " vs. 反引号 `。
    分号：是否强制要求分号？
    逗号：对象或数组最后一项是否需要尾随逗号（ trailing comma ）？
    最大长度：一行代码最多多少个字符？
  代码质量 (Code Quality):
    未使用的变量：禁止声明未使用的变量。
    恒等比较：强制使用 === 和 !==，而不是 == 和 !=。
    禁止 alert：生产代码中禁止使用 alert, confirm 等。
    禁止 eval：因安全和性能原因，禁止使用 eval()。
  最佳实践 (Best Practices):
    函数复杂度：限制函数的圈复杂度，避免函数过于复杂。
    参数修改：是否允许直接修改函数参数。
    Switch Case：强制 switch 语句中有 default 分支。
  框架特定 (Framework-Specific) (如 React):
    Hook 规则：强制 Hook 的使用规则（只能在最顶层调用，只能在 React 函数中调用）。
    JSX 语法：如 JSX 中强制使用 alt 属性。
    Key Prop：列表渲染时必须提供稳定的 key。
5. 如何与编辑器集成？
这才是提升开发体验的关键！集成后，你可以在编码时实时看到错误和警告，并且通常支持保存时自动修复。
以 VS Code 为例：
安装插件：在 VS Code 扩展商店中搜索并安装 ESLint 插件。
启用自动修复：在 VS Code 的设置 (settings.json) 中添加以下配置：
```json
{
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true // 保存时自动修复所有可修复的 ESLint 问题
  },
  "eslint.validate": [ // 指定 ESLint 校验的语言
    "javascript",
    "javascriptreact",
    "typescript",
    "typescriptreact"
  ]
}
```
效果：安装后，你的代码中违反规则的地方会立即出现红色波浪线（错误）或黄色波浪线（警告）。当你保存文件时，ESLint 会自动修复那些可以自动修复的问题（如引号、分号、缩进）。
6. Pre-commit Hook 有什么应用场景？
Pre-commit Hook（预提交钩子） 是 Git 的一个功能，它允许你在执行 git commit 命令之前，自动运行一些自定义的脚本。
在 ESLint 中的经典应用场景：
目的：在代码提交到版本库之前，自动进行检查和修复，确保所有提交的代码都符合规范，防止有问题的代码污染仓库。
如何实现？
通常使用 Husky + lint-staged 这两个库来完美实现。
Husky：让你能轻松地管理 Git Hooks。
lint-staged：只对暂存区（git staged） 的文件运行 linters，速度快，且不会检查整个项目。
配置示例：
安装：npm install --save-dev husky lint-staged
在 package.json 中配置：
```json
{
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [ // 只对暂存区的 js/ts 文件执行以下命令
      "eslint --fix", // 1. 尝试自动修复
      "prettier --write" // 2. (可选) 用 Prettier 格式化
    ]
  },
  "scripts": {
    "prepare": "husky install" // 项目安装后自动初始化 husky
  }
}
```
初始化 Husky 并创建 Hook：npx husky add .husky/pre-commit "npx lint-staged"
效果：以后每次你执行 git commit，Husky 都会在提交前自动触发 lint-staged，lint-staged 会对你本次提交的文件运行 ESLint 修复。如果 ESLint 报错（且无法自动修复），本次提交就会被终止，直到你手动修复所有错误后才能成功提交。

### CI/CD
关于使用GitHub及其提供的GitHub Actions来进行CI/CD服务的原理及步骤
1. 本地的代码写完后，在根目录下创建目录和文件：.github/workflows/deploy.yml
```yml
name: Deploy Vite SPA to Server

on:
  push:
    branches: [ main ] # 当向 main 分支推送代码时触发自动部署

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest # 使用 GitHub 提供的 Ubuntu 虚拟机环境

    steps:
    # 步骤1: 获取你的代码
    - name: Checkout code
      uses: actions/checkout@v3

    # 步骤2: 设置 Node.js 环境
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18' # 指定 Node 版本，应与你的开发环境一致
        cache: 'npm' # 缓存 npm 依赖，加速后续构建

    # 步骤3: 安装依赖
    - name: Install dependencies
      run: npm ci # 使用 `ci` 命令安装，更严格、更快

    # 步骤4: 运行测试（可选，但推荐）
    - name: Run tests
      run: npm run test

    # 步骤5: 执行构建
    - name: Build project
      run: npm run build # 运行 vite build，生成 dist 目录
      env:
          VITE_SENTRY_DSN: ${{ secrets.SENTRY_DSN }} # 构建时注入Sentry DSN


    # 步骤6: 列出构建产物（用于调试，可省略）
    - name: List build outputs
      run: ls -la dist/

    # --- 新增步骤：创建发布版本号（Sentry用） ---
    - name: Create Sentry Release version
      id: sentry-release
      run: |
        # 用git提交的SHA作为版本号，唯一且可追溯
        echo "release=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

    # --- 新增步骤：安装Sentry CLI ---
    - name: Install Sentry CLI
      run: |
        curl -sL https://sentry.io/get-cli/ | bash

    # --- 新增步骤：上传Source Maps到Sentry ---
    - name: Upload source maps to Sentry
      env:
        SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
      run: |
        sentry-cli sourcemaps inject --org=your-org-slug --project=your-project-slug ./dist 
        sentry-cli sourcemaps upload --org=your-org-slug --project=your-project-slug --release=${{ steps.sentry-release.outputs.release }} ./dist
        # --url-prefix 指定线上JS文件的访问地址，至关重要！
        # 告诉Sentry，dist目录下的JS文件，将来在线上是通过 'https://你的CDN域名/assets' 这个路径访问的
        sentry-cli sourcemaps upload --org=your-org-slug --project=your-project-slug \
          --release=${{ steps.sentry-release.outputs.release }} \
          --url-prefix 'https://你的CDN域名/assets' \
          ./dist

    # 步骤7: 部署到服务器（现在会自动排除.map文件）
    - name: Deploy to Server via SSH
      uses: appleboy/ssh-action@master #这个 Action 的作用，就是建立一个 SSH 连接，把它后面 script: 下列出的所有命令，一条一条地发送到你的云服务器上去执行
      with:
        host: ${{ secrets.SSH_HOST }} # 你的服务器IP
        username: ${{ secrets.SSH_USERNAME }} # 登录用户名
        key: ${{ secrets.SSH_PRIVATE_KEY }} #  SSH 私钥
        script: |
          # 这串脚本会在你的服务器上执行！
          cd /path/to/your/project/on/server # 1. 进入服务器上的项目目录
          git pull origin main               # 2. 拉取最新代码（可选）
          rm -rf ./old_dist                  # 3. 删除旧的备份
          mv ./dist ./old_dist               # 4. 备份当前运行的版本
          # 5. 将 GitHub Actions 构建好的 dist 目录复制到服务器项目位置
          sudo cp -r /home/runner/work/your-repo-name/your-repo-name/dist ./
          # 6. 确保你的 Web 服务器（如 Nginx）的根目录指向这个 `dist` 文件夹
          #  Nginx 配置示例: root /path/to/your/project/on/server/dist;
          # 7. 重启 Web 服务器或重新加载配置（如果需要）
          sudo systemctl reload nginx
```
关于yml文件中字段的说明：
  uses：是复用他人写好的** Action（动作）**。比如 actions/checkout@v3 就是一个官方的、用于拉取代码的 Action。你可以把它想象成 npm 包，是共享和复用的单元。社区有无数写好的 Action 供你使用。
  with：是向上面那些 uses 的 Action 传递参数。就像调用函数 func(key: value) 一样。每个 Action 需要什么参数，需要去看它的文档。
  run：这里的命令就是在虚拟机里执行的 shell 命令。npm run build 就是执行你 package.json 里 scripts 中定义的 build 命令。npm test、ls -la 等等也都是 shell 命令。
  Secrets 的使用：
    首先，你去你的云服务商那里获取这三个信息：host（服务器IP）、username（用户名）、key（SSH私钥）。
    然后，你绝对不能把它们直接写在 .yml 文件里！ 因为这会泄露你的服务器密码。
    正确的做法是：将它们以 Secrets 的形式保存在 GitHub 仓库的设置里，并给它们起个名字，比如 SERVER_HOST、SSH_USERNAME、SSH_PRIVATE_KEY。
    最后，在 .yml 文件里，通过 ${{ secrets.SERVER_HOST }} 的方式引用这些秘密变量。
    这样，配置文件本身是公开的，但关键的服务器信息是保密的。

2. 在 GitHub 配置密钥
打开你 GitHub 项目的 Settings -> Secrets and variables -> Actions -> New repository secret。
创建三个密钥：
SSH_HOST: 你的服务器 IP 地址（例如 123.123.123.123）。
SSH_USERNAME: 你的服务器登录用户名（例如 root 或 ubuntu）。
SSH_PRIVATE_KEY: 用于认证的 SSH 私钥（复制你本地 ~/.ssh/id_rsa 文件的内容）。

3. 将本地git仓库commit的版本，进行push到远程GitHub的仓库中
```bash
git add . # 将当前目录所有新文件和修改添加到暂存区
git commit -m "feat: complete project and setup CI/CD" # 提交到本地仓库
git push origin main # 推送到远程GitHub仓库的main分支，触发Actions
```
4. 在上述操作执行后，会发生如下事件
代码被推送到 GitHub 的服务器上。
GitHub 平台检测到这次 push 事件。
它检查这次 push 所包含的代码里，有没有 .github/workflows/ 目录下的 .yml 文件。
发现后，它不会直接操作你提交的代码文件，而是立刻启动一个新的、干净的虚拟机（比如 Ubuntu）。
在这个虚拟机里，GitHub Actions 的“机器人”会：
  a. 拉取你刚刚 push 上来的那份代码（到虚拟机的本地）。
  b. 严格按照 .yml 文件里的“说明书”，一步一步地执行命令。 包括：获取代码、安装依赖、运行测试（可选）、构建打包、部署提交至服务器并告知服务器需要做的事件
  c. 所有步骤执行完后，虚拟机会自动销毁。每次运行都是一个全新的环境。
服务器收到GitHub Actions发出的资料后，会进行：在指定目录进行下载刚刚提交的构建后的资源、删除旧的备份、备份当前最新的资源、确保服务器的根目录指向资源、重启服务器或加载配置（如果需要）
经过上述步骤后，一个源码项目就完成了CI/CD自动化部署。
5. 补充监管系统如Sentry
本质：预埋能监听客户端错误的代码，并将错误上传到Sentry的云端服务器，同时查询sourcemap来定位源码中的位置，并同值程序员知晓，程序员根据错误记录来排查和修改源码，通过CI/CD自动化，构建出结果，并将结果中除了.map外的html、js、css资源传到例如cdn的分发服务器，把.map传到Sentry监测系统的服务器。
操作步骤：
1、在上述的CI/CD GitHub Actions中增加关于Sentry的配置
2、在源码中，下载库
```bash
npm install @sentry/react
```
并在主入口中预埋（通常在 main.jsx/index.js 中）
```jsx
// main.jsx
import { createRoot } from 'react-dom/client';
import App from './App.jsx';
import './index.css';

// 1. 导入Sentry
import * as Sentry from "@sentry/react";

// 2. 初始化Sentry，DSN从环境变量读取
Sentry.init({
  dsn: import.meta.env.VITE_SENTRY_DSN, // 这个DSN是Sentry创建项目获取的一个字符串，其实就是预埋的SDK发送错误的地址。
  integrations: [Sentry.browserTracingIntegration()],
  tracesSampleRate: 1.0, // 性能监控采样率，1.0为全部采集，可根据需要调整
});

createRoot(document.getElementById('root')).render(<App />);
```
3、在Sentry 项目设置中找到 DSN，把它配置到你的 GitHub Secrets 和环境变量文件中（如 .env.production）。通过配置.yml文件后，GitHub Actions能在CI/CD构建时把该DSN预埋至环境变量中的。作用是让客户端运行出错时SDK知道把错误记录发送到什么地址（Sentry服务器中的具体账户）。

4、Sentry 账户设置中生成 Auth Token，并配置到 GitHub Secrets。
主要作用是为了让 CI/CD 流水线（GitHub Actions）有权限向你的 Sentry 项目上传数据（即 Source Map 文件）。

总结一下两个凭证的分工：
凭证	DSN (Data Source Name)	Auth Token
使用者	前端 SDK (在用户的浏览器中运行)	后端工具 (Sentry CLI, 在你的CI/CD中运行)
目的	上报错误事件 (Event)	上传源代码文件 (Source Map, 创建Release)
权限	仅限“上报”	拥有“写入”甚至“管理”项目的更高权限
比喻	信箱投递口：任何人都可以往里塞信（错误）。	仓库后门钥匙：只有管理员才能用钥匙开门放入货物（Source Map）。

补充：在这之前需要注册账号及项目
访问 sentry.io，注册账号。
创建一个新组织（Organization）和项目（Project），选择你的技术栈（如 JavaScript/React）。

### 工程化总结
1、首先我们开发源码。在源码中下载相关的依赖，同时修改源码中的部分代码，比如注入第三方监测错误的SDK。
2、同时，我们将第三方saas服务的相关凭证信息，录入至GitHub项目的设置中。
3、同时，继续将分发服务器的信息，也录入至GitHub的项目设置中。
4、继续修改源码中的.yml配置文件，供GitHub Actions使用。
5、最后我们在控制台commit最终版本到本地git，并push到GitHub远程仓库。
6、GitHub收到push后，会解析.yml文件，运行我们已经设置好的一系列指令。包括：取得源码，注入相关的DSN到环境变量，测试，打包构建出结果文件。然后通过运行Sentry CLI指令把.map文件上传至Sentry服务器以及告知Sentry服务器这个map文件对应的分发服务器地址，最后把除了.map的静态文件上传至分发服务器（如cdn）且告知服务区需要执行的命令（主要就是更新最新的文件并备份）。
7、最后客户端就能访问分发服务器获取网页资源了，且如果出错了，就会运行预埋在js中的SDK向Sentry服务器发送错误日志。然后程序员收到Sentry的错误通知，查询错误修改，再次构建然后上线。


### PC端调试方案
#### debug
1. 单步debug：在源码中插入debugger，或者在浏览器中的源码行前点击加入断点，然后一步步运行，查看代码执行和数据。
2. 单元测试：编写测试用例来验证输出结果是否复合预期。
#### 如何处理线上紧急问题？
线上问题最重要的是快速定位和及时恢复。
处理流程：
  监控告警：通过 Sentry、APM 等工具第一时间发现问题。
  止损：优先恢复服务。常用手段：回滚到上一个稳定版本是最快最有效的方法。
  定位：查看日志、监控图表，定位问题原因。
  修复：在测试环境验证修复方案后，重新上线。
#### 代理映射（反向代理）
来实现线上问题排查或流量切分。
是什么？ 反向代理（如 Nginx）是位于用户和你的服务器之间的一个中间层。它接收用户请求，然后根据规则转发给后端的某台服务器。
怎么用于排查问题？
场景：线上有个用户报障，但你无法复现。你需要让他访问你正在本地调试的版本，来排查问题。
工具：Ngrok / localtunnel / Charles Proxy（代理映射的经典工具）。
用法：
在你的开发机上启动本地服务（如 http://localhost:3000）。
运行 ngrok http 3000。Ngrok 会为你生成一个唯一的公网域名（如 https://abc123.ngrok.io）。
让用户访问这个 https://abc123.ngrok.io 域名。
Ngrok 会将所有到达这个域名的请求，反向代理（映射） 到你本地的 localhost:3000 服务。
这样，用户就在访问你本地正在调试的程序，你可以在本地进行单步 Debug，实时看到用户的请求和数据。
#### sourmap
现代构建工具（Webpack, Vite, Rollup）在生产环境构建时，默认或通过简单配置即可生成 .map 文件。
```js
// vite.config.js / webpack.config.js
export default defineConfig({
  build: {
    sourcemap: true, // 启用 source map 生成
  },
});
```
构建后，你会得到 dist/assets/index.abc123.js 和对应的 dist/assets/index.abc123.js.map。
调试：只要 .map 文件和 .js 文件在同一目录，或通过注释 //# sourceMappingURL=index.abc123.js.map 指明了关联关系，现代浏览器 DevTools 会自动加载它。你打开 Sources 面板，就能看到 webpack:// 或 src/ 目录，里面就是你原始的、可调试的源码。

重要安全提示：
不要将 .map 文件部署到生产服务器！ 因为任何人都可以通过它还原出你的完整源代码。
正确的做法是：在构建服务器上生成 .map 文件，将其上传到错误监控系统（如 Sentry），然后只将压缩后的 .js 文件部署到生产环境。Sentry 可以利用你上传的 .map 文件来解析错误堆栈，而公众无法访问到你的源文件。
#### 错误监控系统，如 Sentry







### 监控埋点
1. 监控埋点是什么？为什么需要？可以做什么？
是什么？ 
  监控埋点是指在应用程序（网页、App）中植入特定的代码，用于收集用户行为数据和业务过程数据，并将这些数据上报到一个数据分析平台。
为什么需要？ 
  为了摆脱“拍脑袋”做决策，实现数据驱动。
  没有埋点：“我觉得用户喜欢这个新按钮。”
  有埋点：“数据显示，新按钮上线后，点击率提升了15%，但整体转化率下降了2%，我们可能需要调整按钮位置。”
可以做什么？
  用户行为分析：用户从哪里来？在页面停留了多久？点击了哪些按钮？浏览路径是什么？
  产品优化：哪个功能最受欢迎？哪个页面流失率最高？如何改进产品流程？
  运营决策：哪个渠道带来的用户质量最高？一次营销活动的效果如何？
  性能监控：关键页面的加载速度如何？哪些操作卡顿？
  异常告警：关键流程的转化率是否出现异常下跌？
2. 如何设计？
a) 埋点类型及业务侵入性
这是设计时最重要的考量，指埋点代码与业务代码的耦合程度。
高侵入性（命令式埋点）：在业务逻辑中直接调用上报代码。
```js
function handleBuyButtonClick() {
  // 业务逻辑
  api.createOrder(...);
  // 埋点代码（高侵入性）
  tracker.event('click_buy', { item_id: '123', price: 99 }); 
}
```
优点：精准、灵活，可以携带丰富的自定义参数。
缺点：耦合度高，埋点代码散落在各处，难以维护。业务开发者需要关心埋点。

低侵入性（声明式/无痕埋点）：
声明式：在HTML元素上通过属性定义埋点。
```html
<button data-track-event="buy_click" data-track-item-id="123">购买</button>
```
然后由一个统一的SDK去自动监听这些元素上的事件并上报。极大降低耦合。
无痕埋点（全埋点）：自动采集所有用户的点击、页面浏览等事件。
优点：几乎无侵入，不会遗漏数据。
缺点：数据量巨大，噪音很多，需要后端进行大量清洗和筛选。

设计考量：目前主流趋势是以声明式为主，命令式为辅。对通用交互（点击、曝光）用声明式，对非常特殊的业务逻辑（如支付成功）再用命令式。

b) 监控指标
埋点数据通常分为两大类：
行为数据（谁、在什么时间、什么地方、做了什么事）：
  事件（Event）：最核心的指标。如 click, pageview, purchase。
  页面浏览量（PV）：页面被浏览的次数。
  独立访客数（UV）：访问网站的独立用户数。
  转化率（Conversion Rate）：完成目标动作（如购买）的用户比例。
  点击率（CTR）：某个按钮或链接被点击的比例。
性能数据（做事的效果怎么样）：
  页面加载时间：如首屏加载时间。
  接口耗时：关键API的请求响应时间。
  业务耗时：完成一个关键流程（如从点击到支付成功）的耗时。

3. 如何实现设计？（规范、稳定性、易用性、实时性）
a) 规范 (Specification)
  首先要定义一套统一的数据规范和上报协议，这是所有后续工作的基础。
  事件命名规范：如 [对象]_[动作] -> product_click, cart_add。
  参数规范：定义通用参数（如 user_id, timestamp）和每个事件的特有参数（如 product_id）。
  文档：维护一个“埋点字典”，让所有人都知道每个事件的含义和参数。
b) 稳定性 (Stability)
  埋点系统本身不能影响业务的稳定性。
  防阻塞：上报逻辑必须是异步的，不能阻塞页面渲染和用户交互。
  防崩溃：SDK内部要有完善的 Try/Catch 机制，自身代码的错误绝不能导致业务程序崩溃。
  队列和合并：采用批量上报策略。将多个埋点事件先存储在内存队列中，达到一定数量或间隔时间后再一次性上报，减少HTTP请求次数。
  失败重试：网络失败后，应将数据存入 LocalStorage 等持久化存储，待网络恢复后重新尝试上报。
c) 易用性 (Usability)
  目标是让业务开发者“傻瓜式” 接入。
  统一的SDK：提供一个简单易用的 tracker 对象。
  自动采集：自动采集页面地址（URL）、用户代理（UA）、设备信息等通用字段。
  类型提示：如果项目使用 TypeScript，可以提供完善的类型定义文件，减少调用错误。
d) 实时日志监控上报
  这关乎数据的可靠性和可排查性。
  Sentry联动：可以将埋点SDK的上报失败事件本身，通过 Sentry 上报！这样你就能知道你的监控系统是否在正常工作。
  Debug模式：在开发环境下，可以将上报的数据同时 Console.log 出来，方便调试。
  采样率：对于超高流量的页面，可以配置采样率（如 1%），只上报一部分数据，以减轻服务器压力。
  实时性：对于关键指标（如支付成功），需要实时上报。对于非关键指标（如用户浏览行为），可以延迟批量上报。

总结
设计一个埋点系统，就是设计一个高效、可靠、无感的数据流水线：
  设计规范：定义要收集什么数据（指标）。
  实现采集：用侵入性最低的方式（声明式）收集数据。
  保证传输：稳定、高效地将数据上报到服务器（队列、批量、重试）。
  进行分析：在后端数据平台进行可视化分析，指导决策。
优秀的埋点系统是业务的“眼睛”，它能让你真正看清用户是如何使用你的产品的。

## 设计思想

### 颜色的格式和设计原则
#### 格式
HSL/HSLA hsl(120, 100%, 50%) hsla(240, 100%, 50%, 0.3)
RGB/RGBA  rgb(255, 0, 0) rgba(0, 255, 0, 0.5)
十六进制 #ff0000
#### 原则
对比度：文本与背景需足够对比度
一致性：题色统一，主色、辅助色
（可以参考设计师分享的色卡进行设计；6-3-1法则：60% 主色（背景/主体），30% 辅助色（按钮/标题），10% 强调色（关键操作））
情感表达：颜色提示功能 红色警示、蓝色确认、绿色成功、黄色警告等等
无障碍：避免仅用颜色传递信息，需要结合具体文字图标传递明确信息


## 社区及规范

### CMD、AMD、CommonJS 这些模块化规范
特性	    CommonJS	       AMD (Async Module Definition)	CMD (Common Module Definition)
设计初衷	服务器端 (Node.js环境)	浏览器端 (异步加载模块)	浏览器端 (异步加载模块)
加载方式	同步加载	异步加载	异步加载
依赖处理	依赖在代码中通过require随时书写	依赖前置 (提前声明所有依赖)	依赖就近 (按需声明依赖)
执行时机	加载后即执行	提前执行	延迟执行 (仅在需要时执行)
经典实现	Node.js	RequireJS	SeaJS
适用场景	后端开发、模块文件在本地磁盘，加载速度快	前端开发，需管理多个模块和复杂依赖	前端开发，推崇简洁和按需加载
代码示例 (定义模块)	module.exports = { ... }	define(['dep1', 'dep2'], function(d1, d2) { ... })	define(function(require, exports, module) { var a = require('./a'); ... })
为何需要模块化？
在模块化规范诞生之前，前端代码通常通过全局变量和script标签顺序管理依赖，容易导致命名冲突、依赖关系混乱、难以维护等问题。CommonJS、AMD、CMD 等规范的出现，正是为了解决这些问题，使 JavaScript 能够更好地构建大型复杂应用。

📦 三大模块化规范详解
CommonJS：同步与模块缓存
CommonJS 规范主要适用于 Node.js 环境。它采用 同步 方式加载模块，这在服务器端是可行的，因为模块文件通常就在本地磁盘，加载速度快128。
CommonJS 模块通过 require 引入，通过 module.exports 或 exports 导出。一个模块无论被 require 多少次，只会被执行一次，后续加载会直接返回缓存的计算结果，除非手动清除缓存1。

AMD：浏览器环境的异步加载
AMD 规范更适合浏览器环境，因为它支持异步加载模块，不会阻塞页面渲染123。AMD 推崇依赖前置，在定义模块时就需要声明其所有依赖126。
RequireJS 是 AMD 规范的经典实现126。它的一个特点是，对于依赖的模块，AMD 是提前执行的（不过从 RequireJS 2.0 开始，也支持延迟执行）126。

CMD：依赖就近与延迟执行
CMD 规范同样专注于浏览器端，也采用异步加载26。它与 AMD 的主要区别在于：

推崇依赖就近：可以在代码的任何地方按需引入依赖，而不是必须在定义时声明所有依赖126。

延迟执行：CMD 推崇尽可能晚地执行依赖模块（as lazy as possible），只有在真正用到时才会执行126。
SeaJS 是 CMD 规范的经典实现167。

⚡ 关于 ES6 模块 (ESM) ——主流选择
ES6（ES2015）带来了语言层面的模块化支持，即 import 和 export 语法。它同时兼容同步和异步加载，并且是静态的，便于静态分析和 Tree Shaking。如今，ES6 模块已成为前端开发的主流选择，无论是在打包工具（如 Webpack, Vite）中还是在现代浏览器中都已得到良好支持。

### 获取最新规范信息的社区和网站
官方渠道：
TC39 GitHub Repository (https://github.com/tc39/proposals)：这里可以跟踪所有提案的状态，从 Stage 0 到 Stage 4，是获取第一手信息的终极来源。
ECMA International (https://www.ecma-international.org/)：发布正式的 ECMAScript 标准规范。
权威文档与社区：
MDN Web Docs (Mozilla Developer Network) (https://developer.mozilla.org/): 查询 JavaScript 语法和 API 最全面、最可靠的文档，包含浏览器兼容性数据。
Stack Overflow (https://stackoverflow.com/)：遇到具体的技术问题时，可以在这里搜索或提问，有庞大的开发者社区互助。
JavaScript Weekly (https://javascriptweekly.com/)：一份很受欢迎的电子邮件周刊，推送 JavaScript 的最新动态、文章、库和工具。
知名博客与资讯：
关注一些知名技术博客或开发者（如 CSS-Tricks, David Walsh's Blog）5，他们经常会分享对新技术的理解和实践。
参加线上的 开发者大会 (如 JSConf, React Conf) 或观看其演讲视频5，也是了解前沿趋势的好方法。
实践工具链：
关注 Babel、Webpack、Vite 等工具的官方文档和更新日志，它们通常会对新的语言特性提供最早的支持和实践5。

